{
  "hash": "ee3c9916c0a73bd8b4394dc7046c3b1a",
  "result": {
    "engine": "knitr",
    "markdown": "---\nexecute: \n  warning: false\n---\n\n\n# Networks in data: an introduction to __{igraph}__\n\nIn this lesson, you will learn how to create graphs from data,\nand how to process and modify `igraph` objects. At the end of this lesson, \nyou will be able to:\n\n- create graphs from edge lists and adjacency matrices;\n- manipulate `igraph` objects;\n- explore node and edge attributes;\n- distinguish different kinds of graphs.\n\nLet's start by loading the packages we will use.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123) # for reproducibility\n\n# Load required packages\nlibrary(here)\nlibrary(tidyverse)\nlibrary(igraph)\n```\n:::\n\n\n## Creating `igraph` objects\n\n### Option 1: the `make_*` functions\n\nThe **igraph** package provides users with a set of functions starting with\n`make_*` that can be used to create graphs. The simplest one\nis `make_empty_graph()`, which creates an empty graph (no edges) with as many\nnodes as you wish. For example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Creating an empty graph with 10 nodes\ng <- make_empty_graph(10)\n\n# Showing the igraph object, and its nodes and edges\ng\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nIGRAPH 5cb281c D--- 10 0 -- \n+ edges from 5cb281c:\n```\n\n\n:::\n\n```{.r .cell-code}\nV(g)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n+ 10/10 vertices, from 5cb281c:\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n\n\n:::\n\n```{.r .cell-code}\nE(g)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n+ 0/0 edges from 5cb281c:\n```\n\n\n:::\n\n```{.r .cell-code}\n# Quickly visualize the graph\nplot(g)\n```\n\n::: {.cell-output-display}\n![](01_networks_in_data_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\nThe exact opposite of `make_empty_graph()` is the function `make_full_graph()`,\nwhich creates a fully connected graph.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a fully connected graph\ng <- make_full_graph(n = 10)\n\n# Show nodes and edges, and plot it\nV(g)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n+ 10/10 vertices, from a6620e7:\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n\n\n:::\n\n```{.r .cell-code}\nE(g)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n+ 45/45 edges from a6620e7:\n [1] 1-- 2 1-- 3 1-- 4 1-- 5 1-- 6 1-- 7 1-- 8 1-- 9 1--10 2-- 3 2-- 4 2-- 5\n[13] 2-- 6 2-- 7 2-- 8 2-- 9 2--10 3-- 4 3-- 5 3-- 6 3-- 7 3-- 8 3-- 9 3--10\n[25] 4-- 5 4-- 6 4-- 7 4-- 8 4-- 9 4--10 5-- 6 5-- 7 5-- 8 5-- 9 5--10 6-- 7\n[37] 6-- 8 6-- 9 6--10 7-- 8 7-- 9 7--10 8-- 9 8--10 9--10\n```\n\n\n:::\n\n```{.r .cell-code}\nplot(g)\n```\n\n::: {.cell-output-display}\n![](01_networks_in_data_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\nTo create a custom graph from pre-defined edges, you'd use the function\n`make_graph()`, which is very flexible. For example, suppose you want to\ncreate a graph based on the following description:\n\n- 10 nodes;\n- 2 edges connecting nodes 1 and 2, and nodes 1 and 5.\n\nYou can do that with `make_graph()` as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng <- make_graph(edges = c(1, 2, 1, 5), n = 10, directed = FALSE)\n\nplot(g)\n```\n\n::: {.cell-output-display}\n![](01_networks_in_data_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\nAlternatively, you can use igraph's formula notation in `make_graph()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng2 <- make_graph(~ 1--2, 1--5, 3, 4, 5, 6, 7, 8, 9, 10)\n\nplot(g2)\n```\n\n::: {.cell-output-display}\n![](01_networks_in_data_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\nBoth approaches above result in the same graph. This can be checked with:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nisomorphic(g, g2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n::: {.callout-tip}\n\n### Practice\n\n1. Create a graph with the following properties:\n\n- 4 nodes named *A*, *B*, *C*, and *D*\n- Edges between node A and all other nodes\n\n2. Recreate the graphs below using the `make_graph()` function.\n\n\n::: {.cell layout-ncol=\"2\"}\n::: {.cell-output-display}\n![](01_networks_in_data_files/figure-html/unnamed-chunk-7-1.png){width=2100}\n:::\n\n::: {.cell-output-display}\n![](01_networks_in_data_files/figure-html/unnamed-chunk-7-2.png){width=2100}\n:::\n\n::: {.cell-output-display}\n![](01_networks_in_data_files/figure-html/unnamed-chunk-7-3.png){width=2100}\n:::\n\n::: {.cell-output-display}\n![](01_networks_in_data_files/figure-html/unnamed-chunk-7-4.png){width=2100}\n:::\n:::\n\n\n3. The function `make_graph()` can also create some notable graphs when\nusers specify their names as input. Read the documentation of this function\n(accessible by running `?make_graph`) and visualize at least 5 examples.\n\n::: {.callout appearance=\"minimal\" collapse=\"true\"}\n\n### Show me the solutions\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Q1\ng1 <- make_graph(edges = c(\"A\", \"B\", \"A\", \"C\", \"A\", \"D\"))\n\n# Q2\ng1 <- make_graph(edges = c(1,2, 1,3, 1,4, 1,5, 1,6), n = 6, directed = FALSE)\ng2 <- make_graph(~ A--B, B--C, C--D, D--E)\ng3 <- make_graph(~A--B, B--C, C--A)\ng4 <- make_graph(~A--B, B--C, B--D, C--E, C--F)\n\n# Q3\nsolids <- list(\n  make_graph(\"Tetrahedron\"),\n  make_graph(\"Cubical\"),\n  make_graph(\"Octahedron\"),\n  make_graph(\"Dodecahedron\"),\n  make_graph(\"Icosahedron\")\n)\n\nplot(solids[[1]])\n```\n\n::: {.cell-output-display}\n![](01_networks_in_data_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n\n```{.r .cell-code}\nplot(solids[[2]])\n```\n\n::: {.cell-output-display}\n![](01_networks_in_data_files/figure-html/unnamed-chunk-8-2.png){width=672}\n:::\n\n```{.r .cell-code}\nplot(solids[[3]])\n```\n\n::: {.cell-output-display}\n![](01_networks_in_data_files/figure-html/unnamed-chunk-8-3.png){width=672}\n:::\n\n```{.r .cell-code}\nplot(solids[[4]])\n```\n\n::: {.cell-output-display}\n![](01_networks_in_data_files/figure-html/unnamed-chunk-8-4.png){width=672}\n:::\n\n```{.r .cell-code}\nplot(solids[[5]])\n```\n\n::: {.cell-output-display}\n![](01_networks_in_data_files/figure-html/unnamed-chunk-8-5.png){width=672}\n:::\n:::\n\n\n:::\n:::\n\n### Option 2: from an adjacency matrix\n\nConstructing graphs manually using the `make_graph()` function can be useful\nfor schematic examples or for very small graphs. However, real-world network\nanalyses usually involve working with large graphs, with hundreds (or even\nthousands) of nodes. A very common way of representing networks with data\nconsists in using **adjacency matrices**. An adjacency matrix $m_{ij}$ contains \nnodes in rows and columns, and matrix elements indicate whether there is an \nedge between nodes *i* and *j*. Let's simulate an adjacency matrix:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Simulate an adjacency matrix\nadjm <- matrix(\n    sample(0:1, 100, replace = TRUE, prob = c(0.9, 0.1)), \n    ncol = 10,\n    dimnames = list(LETTERS[1:10], LETTERS[1:10])\n)\n\nadjm\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  A B C D E F G H I J\nA 0 0 0 0 0 0 0 1 1 0\nB 0 0 1 0 0 0 0 0 0 0\nC 0 0 0 0 1 0 0 0 0 1\nD 0 0 0 0 0 1 0 0 0 1\nE 0 0 0 0 0 1 1 1 0 0\nF 0 0 0 0 0 0 0 0 0 0\nG 0 0 0 0 1 1 0 0 0 0\nH 0 0 0 0 0 0 0 0 0 0\nI 0 0 0 0 0 0 0 0 0 0\nJ 0 0 0 0 0 0 0 0 0 0\n```\n\n\n:::\n:::\n\n\nIn this example, we have a binary matrix, with 1 indicating that two nodes\ninteract, and 0 indicating otherwise. We could also have numeric values\n(e.g., from 0 to 1) in matrix elements instead of 0s and 1s, \nwhich would then indicate the strength of the link between two nodes.\nYou can create an `igraph` object from an adjacency matrix with the function\n`graph_from_adjacency_matrix()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a graph from an adjacency matrix\ng <- graph_from_adjacency_matrix(adjm)\n\ng\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nIGRAPH 0acc06b DN-- 10 12 -- \n+ attr: name (v/c)\n+ edges from 0acc06b (vertex names):\n [1] A->H A->I B->C C->E C->J D->F D->J E->F E->G E->H G->E G->F\n```\n\n\n:::\n\n```{.r .cell-code}\nplot(g)\n```\n\n::: {.cell-output-display}\n![](01_networks_in_data_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n### Option 3: from an edge list\n\nAnother very common way of representing networks in data consists in using\n**edge lists**, which are data frames containing the edges in columns 1 and 2.\nAny additional columns will be interpreted as (optional) edge attributes.\nLet's simulate an edge list.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Simulate an edge list\nedgelist <- data.frame(\n    from = c(\"A\", \"A\", \"B\"),\n    to = c(\"B\", \"C\", \"C\")\n)\n\nedgelist\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  from to\n1    A  B\n2    A  C\n3    B  C\n```\n\n\n:::\n:::\n\n\nAs in an adjacency matrix, you could also add a third column indicating\nthe strength of the edge. You can create an `igraph` object from an edge list \nwith the functions `graph_from_edgelist()` or `graph_from_data_frame()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a graph from an edge list\ng <- graph_from_edgelist(as.matrix(edgelist))\ng2 <- graph_from_data_frame(edgelist)\n\nidentical_graphs(g, g2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nplot(g)\n```\n\n::: {.cell-output-display}\n![](01_networks_in_data_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\n## Understanding and constructing different network types\n\nGraphs can be classified into different types based on edge attributes\nnamed **directionality** and **weight**. These graph types are:\n\n1. **Directed** vs **undirected**: in directed graphs, edges have a \ndirection (i.e., *from* a node *to* another), while in undirected graphs\nsuch directions do not exist.\n2. **Weighted** vs **unweighted**: in weighted graphs, edges have weights\nindicating the strength of association between two nodes, while in unweighted\ngraphs edges are binary.\n\nTo demonstrate how to create these different graph types, consider the \nedge list below:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create edge list with weights\nedges <- data.frame(\n    from = c(\"A\", \"A\", \"B\", \"C\"),\n    to = c(\"B\", \"C\", \"C\", \"D\"),\n    weight = sample(seq(0, 1, by = 0.1), 4)\n)\n\nedges\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  from to weight\n1    A  B    0.8\n2    A  C    0.5\n3    B  C    0.7\n4    C  D    0.3\n```\n\n\n:::\n:::\n\n\nYou can create four different graph types from this edge list by\nplaying with arguments in `graph_from_data_frame()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Graph 1: unweighted, undirected\ng1 <- graph_from_data_frame(edges[, c(1,2)], directed = FALSE)\n\n# Graph 2: unweighted, directed\ng2 <- graph_from_data_frame(edges[, c(1,2)], directed = TRUE)\n\n# Graph 3: weighted, undirected\ng3 <- graph_from_data_frame(edges, directed = FALSE)\n\n# Graph 4: weighted, directed\ng4 <- graph_from_data_frame(edges, directed = TRUE)\n\n# Show igraph objects\nlist(g1, g2, g3, g4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\nIGRAPH 7ff90df UN-- 4 4 -- \n+ attr: name (v/c)\n+ edges from 7ff90df (vertex names):\n[1] A--B A--C B--C C--D\n\n[[2]]\nIGRAPH 8dbda16 DN-- 4 4 -- \n+ attr: name (v/c)\n+ edges from 8dbda16 (vertex names):\n[1] A->B A->C B->C C->D\n\n[[3]]\nIGRAPH 582f71d UNW- 4 4 -- \n+ attr: name (v/c), weight (e/n)\n+ edges from 582f71d (vertex names):\n[1] A--B A--C B--C C--D\n\n[[4]]\nIGRAPH 247f104 DNW- 4 4 -- \n+ attr: name (v/c), weight (e/n)\n+ edges from 247f104 (vertex names):\n[1] A->B A->C B->C C->D\n```\n\n\n:::\n:::\n\n\nWhen the edge list includes a third column with a numeric variable, the\nfunction `graph_from_data_frame()` automatically adds it as an edge attribute\nnamed **weight**. You can add as many edge attributes as you wish.\n\nBesides adding edge attributes, you can also add node (or vertex) attributes.\nIn the example below, we create a more complex graph, with multiple edge and\nnode attributes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create edge list with two edge attributes\nedges <- data.frame(\n    from = c(\"A\", \"A\", \"B\", \"C\"),\n    to = c(\"B\", \"C\", \"C\", \"D\"),\n    weight = sample(seq(-1, 1, by = 0.1), 4)\n)\nedges$weight_type <- ifelse(edges$weight > 0, \"positive\", \"negative\")\n\nedges\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  from to weight weight_type\n1    A  B    0.0    negative\n2    A  C    1.0    positive\n3    B  C   -0.2    negative\n4    C  D    0.5    positive\n```\n\n\n:::\n\n```{.r .cell-code}\n# Create a data frame of node attributes\nnode_attrs <- data.frame(\n    node = c(\"A\", \"B\", \"C\", \"D\"),\n    group = c(1, 1, 2, 2)\n)\n\nnode_attrs\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  node group\n1    A     1\n2    B     1\n3    C     2\n4    D     2\n```\n\n\n:::\n\n```{.r .cell-code}\n# Create a graph with both edge and node attributes\ncg <- graph_from_data_frame(edges, directed = FALSE, vertices = node_attrs)\n\ncg\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nIGRAPH c1988bd UNW- 4 4 -- \n+ attr: name (v/c), group (v/n), weight (e/n), weight_type (e/c)\n+ edges from c1988bd (vertex names):\n[1] A--B A--C B--C C--D\n```\n\n\n:::\n\n```{.r .cell-code}\n# Printing node and edge attributes\nvertex_attr_names(cg)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"name\"  \"group\"\n```\n\n\n:::\n\n```{.r .cell-code}\nedge_attr_names(cg)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"weight\"      \"weight_type\"\n```\n\n\n:::\n:::\n\n\n::: {.callout-tip}\n\n### Practice\n\n1. The code below creates a correlation matrix from the `mtcars` data set.\nUse this correlation matrix to create an undirected weighted graph.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncormat <- cor(t(mtcars[, c(1, 3:7)]))\n```\n:::\n\n\n2. The code below converts the correlation matrix created above to an edge \nlist. Create the same graph you created before, but now from an edge list.\nThen, check if graphs are indeed the same. \n\n*Hint:* use the `simplify()` function to remove loops (edges that connect\na node to itself).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncormat_edges <- reshape2::melt(cormat)\n```\n:::\n\n\n3. From the edge list created above, add an edge attribute named `strength`\nthat contains the character **strong** for edges with weight >=0.9, \nand **moderate** otherwise. Then, create a graph and inspect this attribute.\n\n4. From the edge list created in question 3, create a data frame\nof node attributes containing an attribute named `brand` containing the brands\nof each car.\n\n::: {.callout appearance=\"minimal\" collapse=\"true\"}\n\n### Show me the solutions\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Q1\ng <- graph_from_adjacency_matrix(\n    cormat, mode = \"undirected\", weighted = TRUE, diag = FALSE\n)\n\n# Q2\ng2 <- graph_from_data_frame(cormat_edges, directed = FALSE)\nisomorphic(g, simplify(g2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n# Q3\ng3 <- cormat_edges |>\n    mutate(strength = ifelse(value >= 0.9, \"strong\", \"moderate\")) |>\n    graph_from_data_frame(directed = FALSE)\n\n# Q4\nbrands <- data.frame(node = unique(c(cormat_edges$Var1, cormat_edges$Var2))) |>\n    mutate(brand = gsub(\" .*\", \"\", node))\n\ng4 <- graph_from_data_frame(cormat_edges, directed = FALSE, vertices = brands)\n```\n:::\n\n\n:::\n:::\n\n## Manipulating `igraph` objects\n\nTo add or remove nodes from an `igraph` object, you can use the \nfunctions `add_vertices()` and `delete_vertices()` as demonstrated below:\n\n\n::: {.cell layout-ncol=\"3\"}\n\n```{.r .cell-code}\n# Create empty graph with 4 nodes\ng <- make_empty_graph(4)\nplot(g)\n```\n\n::: {.cell-output-display}\n![](01_networks_in_data_files/figure-html/unnamed-chunk-19-1.png){width=2100}\n:::\n\n```{.r .cell-code}\n# Add 3 nodes\ng <- add_vertices(g, 3)\nplot(g)\n```\n\n::: {.cell-output-display}\n![](01_networks_in_data_files/figure-html/unnamed-chunk-19-2.png){width=2100}\n:::\n\n```{.r .cell-code}\n# Remove nodes 6 and 7\ng <- delete_vertices(g, c(6, 7))\nplot(g)\n```\n\n::: {.cell-output-display}\n![](01_networks_in_data_files/figure-html/unnamed-chunk-19-3.png){width=2100}\n:::\n:::\n\n\nSimilarly, you can add edges to an `igraph` object with the function\n`add_edges()`.\n\n\n::: {.cell layout-ncol=\"2\"}\n\n```{.r .cell-code}\n# Create empty graph with 4 nodes\ng <- make_empty_graph(4)\nplot(g)\n```\n\n::: {.cell-output-display}\n![](01_networks_in_data_files/figure-html/unnamed-chunk-20-1.png){width=2100}\n:::\n\n```{.r .cell-code}\n# Add edges 1--2, 1--3 and 1--4\ng <- add_edges(g, edges = c(1,2, 1,3, 1,4))\nplot(g)\n```\n\n::: {.cell-output-display}\n![](01_networks_in_data_files/figure-html/unnamed-chunk-20-2.png){width=2100}\n:::\n:::\n\n\nTo remove edges, you will first need to get the IDs of the edges you want to\nremove. This can be done with the function `get.edge_ids()`. Once you have the\nIDs of the edges to be removed, you can use the function `delete_edges()` to\ndo so.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get IDs of edges 1--2 and 1--3\nids_remove <- get.edge.ids(g, c(1,2, 1,3))\n\n# Remove edges indicated in `ids_remove`\ng <- delete_edges(g, ids_remove)\n\nplot(g)\n```\n\n::: {.cell-output-display}\n![](01_networks_in_data_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n:::\n\n\nBesides adding/removing nodes and edges, you can also add/remove node and edge\nattributes. These can be done in two ways: with the functions\n`set_vertex_attr()` and `set_edge_attr()`, or using the `$` operator in the \noutput of `V()` and `E()` the same way you do when adding a variable \nto a data frame. For example, consider the graph below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create graph using the 'Zachary' (karate club) data set\ng <- make_graph(\"Zachary\")\n\nplot(g)\n```\n\n::: {.cell-output-display}\n![](01_networks_in_data_files/figure-html/unnamed-chunk-22-1.png){width=672}\n:::\n:::\n\n\nYou can add node attributes using one of the following approaches:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Simulate a node attribute `sex` with 'male' and 'female'\nsex <- sample(c(\"male\", \"female\"), vcount(g), replace = TRUE)\n\n# Approach 1: set_vertex_attr()\ng1 <- set_vertex_attr(g, \"gender\", value = sex)\n\nvertex_attr_names(g1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"gender\"\n```\n\n\n:::\n\n```{.r .cell-code}\nV(g1)$gender\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"male\"   \"female\" \"female\" \"male\"   \"male\"   \"male\"   \"female\" \"male\"  \n [9] \"male\"   \"female\" \"male\"   \"male\"   \"female\" \"male\"   \"male\"   \"male\"  \n[17] \"male\"   \"male\"   \"female\" \"female\" \"male\"   \"male\"   \"male\"   \"female\"\n[25] \"male\"   \"female\" \"male\"   \"male\"   \"male\"   \"female\" \"female\" \"female\"\n[33] \"female\" \"male\"  \n```\n\n\n:::\n\n```{.r .cell-code}\n# Approach 2: $ operator\ng2 <- g\nV(g2)$gender <- sex\n\nvertex_attr_names(g2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"gender\"\n```\n\n\n:::\n\n```{.r .cell-code}\nV(g2)$gender\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"male\"   \"female\" \"female\" \"male\"   \"male\"   \"male\"   \"female\" \"male\"  \n [9] \"male\"   \"female\" \"male\"   \"male\"   \"female\" \"male\"   \"male\"   \"male\"  \n[17] \"male\"   \"male\"   \"female\" \"female\" \"male\"   \"male\"   \"male\"   \"female\"\n[25] \"male\"   \"female\" \"male\"   \"male\"   \"male\"   \"female\" \"female\" \"female\"\n[33] \"female\" \"male\"  \n```\n\n\n:::\n\n```{.r .cell-code}\n# Checking if graphs are the same\nidentical_graphs(g1, g2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\nThe same can be done for edge attributes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Simulate an edge attribute `weight`\nweight <- runif(ecount(g), 0, 1)\n\n# Approach 1: set_edge_attr()\ng1 <- set_edge_attr(g, \"weight\", value = weight)\n\nedge_attr_names(g1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"weight\"\n```\n\n\n:::\n\n```{.r .cell-code}\nE(g1)$weight\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 0.90738049 0.37635786 0.34531326 0.21946586 0.13228278 0.13507009\n [7] 0.08853259 0.78730386 0.35807888 0.29391158 0.40450132 0.13381784\n[13] 0.46851664 0.96685776 0.43449663 0.20073533 0.91053219 0.06783826\n[19] 0.82759449 0.23656741 0.27750932 0.67660508 0.71850210 0.59585793\n[25] 0.90803670 0.96113321 0.30684454 0.32653913 0.17554868 0.47100477\n[31] 0.16614016 0.01465749 0.57004785 0.01040247 0.05366550 0.93736147\n[37] 0.27528845 0.49616664 0.38447575 0.83071796 0.96821445 0.42522784\n[43] 0.61622431 0.43404264 0.50350546 0.70605198 0.84839995 0.81655145\n[49] 0.83680556 0.82331943 0.94625621 0.10089687 0.92175100 0.09025842\n[55] 0.01070081 0.31031531 0.77869046 0.74516384 0.07696548 0.52209787\n[61] 0.06152497 0.81003844 0.78088586 0.55043131 0.08312209 0.11898886\n[67] 0.07949653 0.58837430 0.88259873 0.95365913 0.85435595 0.32205234\n[73] 0.71748372 0.96839190 0.68511963 0.46812786 0.26695170 0.07534844\n```\n\n\n:::\n\n```{.r .cell-code}\n# Approach 2: $ operator\ng2 <- g\nE(g2)$weight <- weight\n\nedge_attr_names(g2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"weight\"\n```\n\n\n:::\n\n```{.r .cell-code}\nE(g2)$weight\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 0.90738049 0.37635786 0.34531326 0.21946586 0.13228278 0.13507009\n [7] 0.08853259 0.78730386 0.35807888 0.29391158 0.40450132 0.13381784\n[13] 0.46851664 0.96685776 0.43449663 0.20073533 0.91053219 0.06783826\n[19] 0.82759449 0.23656741 0.27750932 0.67660508 0.71850210 0.59585793\n[25] 0.90803670 0.96113321 0.30684454 0.32653913 0.17554868 0.47100477\n[31] 0.16614016 0.01465749 0.57004785 0.01040247 0.05366550 0.93736147\n[37] 0.27528845 0.49616664 0.38447575 0.83071796 0.96821445 0.42522784\n[43] 0.61622431 0.43404264 0.50350546 0.70605198 0.84839995 0.81655145\n[49] 0.83680556 0.82331943 0.94625621 0.10089687 0.92175100 0.09025842\n[55] 0.01070081 0.31031531 0.77869046 0.74516384 0.07696548 0.52209787\n[61] 0.06152497 0.81003844 0.78088586 0.55043131 0.08312209 0.11898886\n[67] 0.07949653 0.58837430 0.88259873 0.95365913 0.85435595 0.32205234\n[73] 0.71748372 0.96839190 0.68511963 0.46812786 0.26695170 0.07534844\n```\n\n\n:::\n\n```{.r .cell-code}\n# Checking if graphs are the same\nidentical_graphs(g1, g2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n::: {.callout-tip}\n\n### Practice\n\n1. Use the code below to create an `igraph` object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create `igraph` object from mtcars data set\ngraph <- cor(t(mtcars[, c(1, 3:7)])) |> \n    graph_from_adjacency_matrix(\n        mode = \"undirected\", weighted = TRUE, diag = FALSE\n    )\n```\n:::\n\n\nThen, add the following attributes:\n\n- An edge attribute named `strength` that contains the character \n**strong** for edges with weight >=0.9, and **moderate** otherwise.\n- A node attribute named `brand` containing the brands of each car.\n\n*Hint:* this is the same exercise you did in a previous section, but now\nyou're adding attributes using the `igraph` object itself, not the\ngraph's edge list.\n\n2. Using the graph created above, remove edges with attribute `weight` <0.95.\n\n*Hint:* you can use logical subsetting to extract edges that match the\nrequired condition.\n\n::: {.callout appearance=\"minimal\" collapse=\"true\"}\n\n### Show me the solutions\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Q1\nE(graph)$strength <- ifelse(E(graph)$weight >= 0.9, \"strong\", \"moderate\")\nV(graph)$brand <- gsub(\" .*\", \"\", V(graph)$name)\n\nE(graph)$strength\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  [1] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n  [7] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n [13] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n [19] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n [25] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n [31] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n [37] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n [43] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n [49] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n [55] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n [61] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n [67] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n [73] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n [79] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n [85] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n [91] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n [97] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[103] \"strong\"   \"strong\"   \"strong\"   \"moderate\" \"strong\"   \"strong\"  \n[109] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"moderate\"\n[115] \"strong\"   \"moderate\" \"moderate\" \"strong\"   \"strong\"   \"strong\"  \n[121] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[127] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[133] \"moderate\" \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[139] \"strong\"   \"strong\"   \"moderate\" \"strong\"   \"moderate\" \"moderate\"\n[145] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[151] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[157] \"strong\"   \"strong\"   \"moderate\" \"strong\"   \"strong\"   \"strong\"  \n[163] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"moderate\" \"strong\"  \n[169] \"moderate\" \"moderate\" \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[175] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[181] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[187] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[193] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[199] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[205] \"strong\"   \"strong\"   \"strong\"   \"moderate\" \"strong\"   \"strong\"  \n[211] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"moderate\"\n[217] \"strong\"   \"moderate\" \"moderate\" \"strong\"   \"strong\"   \"strong\"  \n[223] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[229] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[235] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[241] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[247] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[253] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[259] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[265] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[271] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[277] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[283] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[289] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[295] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[301] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[307] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[313] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[319] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[325] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[331] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[337] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[343] \"strong\"   \"strong\"   \"strong\"   \"moderate\" \"strong\"   \"moderate\"\n[349] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[355] \"strong\"   \"moderate\" \"strong\"   \"moderate\" \"moderate\" \"strong\"  \n[361] \"strong\"   \"strong\"   \"strong\"   \"moderate\" \"strong\"   \"strong\"  \n[367] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"moderate\"\n[373] \"strong\"   \"moderate\" \"moderate\" \"strong\"   \"strong\"   \"strong\"  \n[379] \"moderate\" \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[385] \"strong\"   \"strong\"   \"moderate\" \"strong\"   \"moderate\" \"strong\"  \n[391] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[397] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[403] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[409] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[415] \"strong\"   \"moderate\" \"moderate\" \"strong\"   \"strong\"   \"moderate\"\n[421] \"moderate\" \"strong\"   \"moderate\" \"strong\"   \"strong\"   \"strong\"  \n[427] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[433] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[439] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[445] \"strong\"   \"strong\"   \"moderate\" \"strong\"   \"moderate\" \"moderate\"\n[451] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"moderate\"\n[457] \"strong\"   \"moderate\" \"moderate\" \"strong\"   \"strong\"   \"strong\"  \n[463] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[469] \"strong\"   \"strong\"   \"moderate\" \"strong\"   \"moderate\" \"moderate\"\n[475] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[481] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[487] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[493] \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n```\n\n\n:::\n\n```{.r .cell-code}\nV(graph)$brand\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"Mazda\"    \"Mazda\"    \"Datsun\"   \"Hornet\"   \"Hornet\"   \"Valiant\" \n [7] \"Duster\"   \"Merc\"     \"Merc\"     \"Merc\"     \"Merc\"     \"Merc\"    \n[13] \"Merc\"     \"Merc\"     \"Cadillac\" \"Lincoln\"  \"Chrysler\" \"Fiat\"    \n[19] \"Honda\"    \"Toyota\"   \"Toyota\"   \"Dodge\"    \"AMC\"      \"Camaro\"  \n[25] \"Pontiac\"  \"Fiat\"     \"Porsche\"  \"Lotus\"    \"Ford\"     \"Ferrari\" \n[31] \"Maserati\" \"Volvo\"   \n```\n\n\n:::\n\n```{.r .cell-code}\n# Q2\nedges_remove <- E(graph)[E(graph)$weight < 0.95]\nfgraph <- delete_edges(graph, edges_remove)\n```\n:::\n\n\n:::\n:::\n\n## Subsetting nodes and edges\n\nTo subset particular nodes and edges from an `igraph` object, you can\nuse subsetting (logical or index-based) based on the output of `V()` \nand `E()`, respectively. For instance, consider the graph below:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create Scooby-Doo network\nedges <- data.frame(\n    from = c(\"Fred\", \"Fred\", \"Fred\", \"Velma\", \"Daphne\", \"Shaggy\"),\n    to = c(\"Velma\", \"Daphne\", \"Shaggy\", \"Shaggy\", \"Shaggy\", \"Scooby\")\n)\n\ng <- graph_from_data_frame(edges, directed = FALSE)\n\ng\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nIGRAPH dc1e72d UN-- 5 6 -- \n+ attr: name (v/c)\n+ edges from dc1e72d (vertex names):\n[1] Fred  --Velma  Fred  --Daphne Fred  --Shaggy Velma --Shaggy Daphne--Shaggy\n[6] Shaggy--Scooby\n```\n\n\n:::\n\n```{.r .cell-code}\nplot(g)\n```\n\n::: {.cell-output-display}\n![](01_networks_in_data_files/figure-html/unnamed-chunk-27-1.png){width=672}\n:::\n:::\n\n\nTo demonstrate how to subset nodes, let's subset only nodes 'Shaggy' and\n'Scooby'.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Subset nodes 'Scooby' and 'Shaggy'\nV(g)[\"Scooby\", \"Shaggy\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n+ 2/5 vertices, named, from dc1e72d:\n[1] Scooby Shaggy\n```\n\n\n:::\n\n```{.r .cell-code}\n# Same, but using indices\nV(g)[c(4,5)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n+ 2/5 vertices, named, from dc1e72d:\n[1] Shaggy Scooby\n```\n\n\n:::\n\n```{.r .cell-code}\n# Same again, but using logical subsetting\nV(g)[startsWith(name, \"S\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n+ 2/5 vertices, named, from dc1e72d:\n[1] Shaggy Scooby\n```\n\n\n:::\n:::\n\n\nIn the third example above, note how node attributes (`name`) can be directly\nused for subsetting inside the brackets of `V()`.\n\nTo subset edges, you'd use the same approach, but now with the `E()` function.\nAs an example, let's subset all edges that include node 'Shaggy'.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Subset edges including node 'Shaggy'\nE(g)[.from(\"Shaggy\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n+ 4/6 edges from dc1e72d (vertex names):\n[1] Fred  --Shaggy Velma --Shaggy Daphne--Shaggy Shaggy--Scooby\n```\n\n\n:::\n\n```{.r .cell-code}\n# Same, but using indices\nE(g)[3:6]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n+ 4/6 edges from dc1e72d (vertex names):\n[1] Fred  --Shaggy Velma --Shaggy Daphne--Shaggy Shaggy--Scooby\n```\n\n\n:::\n:::\n\n\n::: {.callout-tip}\n\n### Practice\n\nUse the code below to load an `igraph` object containing character \nrelationships in the TV show \"Game of Thrones\".\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load Game of Thrones network\ngot <- readRDS(here(\"data\", \"got.rds\"))\n```\n:::\n\n\nThen, subset the edges that include the characters 'Arya', 'Sansa', 'Jon',\n'Robb', 'Bran', and 'Rickon'. Which of these characters has more connections?\n\n\n::: {.callout appearance=\"minimal\" collapse=\"true\"}\n\n### Show me the solutions\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Q1\nstark_connections <- list(\n    Arya = E(got)[.from(\"Arya\")],\n    Sansa = E(got)[.from(\"Sansa\")],\n    Jon = E(got)[.from(\"Jon\")],\n    Robb = E(got)[.from(\"Robb\")],\n    Bran = E(got)[.from(\"Bran\")],\n    Rickon = E(got)[.from(\"Rickon\")]\n)\n\nlengths(stark_connections)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Arya  Sansa    Jon   Robb   Bran Rickon \n    19     26     26     25     14      6 \n```\n\n\n:::\n:::\n\n\n:::\n:::\n\n## Exporting graphs\n\nSometimes, users want to export their `igraph` objects to a file\nso they can visualize them in a network visualization software. This can\nbe done with the function `write_graph()`, which exports `igraph` objects\nto multiple formats specified in the argument *format* (see `?write_graph()`\nfor details). \n\nFor example, [Cytoscape](https://cytoscape.org/) is a very \npopular graph visualization tool, and it can take graphs as edge lists.\nTo export `igraph` objects to edge lists, you could use the following code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Export graph in `g` to a file named 'edgelist.txt'\nwrite_graph(g, file = \"edgelist.txt\", format = \"edgelist\")\n```\n:::\n\n\n\n## Session information {.unnumbered}\n\nThis chapter was created under the following conditions:\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.2 (2023-10-31)\n os       Ubuntu 22.04.3 LTS\n system   x86_64, linux-gnu\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       Europe/Brussels\n date     2024-04-19\n pandoc   3.1.1 @ /usr/lib/rstudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package     * version date (UTC) lib source\n cli           3.6.2   2023-12-11 [1] CRAN (R 4.3.2)\n colorspace    2.1-0   2023-01-23 [1] CRAN (R 4.3.2)\n digest        0.6.34  2024-01-11 [1] CRAN (R 4.3.2)\n dplyr       * 1.1.4   2023-11-17 [1] CRAN (R 4.3.2)\n evaluate      0.23    2023-11-01 [1] CRAN (R 4.3.2)\n fansi         1.0.6   2023-12-08 [1] CRAN (R 4.3.2)\n fastmap       1.1.1   2023-02-24 [1] CRAN (R 4.3.2)\n forcats     * 1.0.0   2023-01-29 [1] CRAN (R 4.3.2)\n generics      0.1.3   2022-07-05 [1] CRAN (R 4.3.2)\n ggplot2     * 3.5.0   2024-02-23 [1] CRAN (R 4.3.2)\n glue          1.7.0   2024-01-09 [1] CRAN (R 4.3.2)\n gtable        0.3.4   2023-08-21 [1] CRAN (R 4.3.2)\n here        * 1.0.1   2020-12-13 [1] CRAN (R 4.3.2)\n hms           1.1.3   2023-03-21 [1] CRAN (R 4.3.2)\n htmltools     0.5.7   2023-11-03 [1] CRAN (R 4.3.2)\n htmlwidgets   1.6.4   2023-12-06 [1] CRAN (R 4.3.2)\n igraph      * 2.0.1.1 2024-01-30 [1] CRAN (R 4.3.2)\n jsonlite      1.8.8   2023-12-04 [1] CRAN (R 4.3.2)\n knitr         1.45    2023-10-30 [1] CRAN (R 4.3.2)\n lifecycle     1.0.4   2023-11-07 [1] CRAN (R 4.3.2)\n lubridate   * 1.9.3   2023-09-27 [1] CRAN (R 4.3.2)\n magrittr      2.0.3   2022-03-30 [1] CRAN (R 4.3.2)\n munsell       0.5.0   2018-06-12 [1] CRAN (R 4.3.2)\n pillar        1.9.0   2023-03-22 [1] CRAN (R 4.3.2)\n pkgconfig     2.0.3   2019-09-22 [1] CRAN (R 4.3.2)\n plyr          1.8.9   2023-10-02 [1] CRAN (R 4.3.2)\n purrr       * 1.0.2   2023-08-10 [1] CRAN (R 4.3.2)\n R6            2.5.1   2021-08-19 [1] CRAN (R 4.3.2)\n Rcpp          1.0.12  2024-01-09 [1] CRAN (R 4.3.2)\n readr       * 2.1.5   2024-01-10 [1] CRAN (R 4.3.2)\n reshape2      1.4.4   2020-04-09 [1] CRAN (R 4.3.2)\n rlang         1.1.3   2024-01-10 [1] CRAN (R 4.3.2)\n rmarkdown     2.25    2023-09-18 [1] CRAN (R 4.3.2)\n rprojroot     2.0.4   2023-11-05 [1] CRAN (R 4.3.2)\n rstudioapi    0.15.0  2023-07-07 [1] CRAN (R 4.3.2)\n scales        1.3.0   2023-11-28 [1] CRAN (R 4.3.2)\n sessioninfo   1.2.2   2021-12-06 [1] CRAN (R 4.3.2)\n stringi       1.8.3   2023-12-11 [1] CRAN (R 4.3.2)\n stringr     * 1.5.1   2023-11-14 [1] CRAN (R 4.3.2)\n tibble      * 3.2.1   2023-03-20 [1] CRAN (R 4.3.2)\n tidyr       * 1.3.1   2024-01-24 [1] CRAN (R 4.3.2)\n tidyselect    1.2.0   2022-10-10 [1] CRAN (R 4.3.2)\n tidyverse   * 2.0.0   2023-02-22 [1] CRAN (R 4.3.2)\n timechange    0.3.0   2024-01-18 [1] CRAN (R 4.3.2)\n tzdb          0.4.0   2023-05-12 [1] CRAN (R 4.3.2)\n utf8          1.2.4   2023-10-22 [1] CRAN (R 4.3.2)\n vctrs         0.6.5   2023-12-01 [1] CRAN (R 4.3.2)\n withr         3.0.0   2024-01-16 [1] CRAN (R 4.3.2)\n xfun          0.42    2024-02-08 [1] CRAN (R 4.3.2)\n yaml          2.3.8   2023-12-11 [1] CRAN (R 4.3.2)\n\n [1] /home/faalm/R/x86_64-pc-linux-gnu-library/4.3\n [2] /usr/local/lib/R/site-library\n [3] /usr/lib/R/site-library\n [4] /usr/lib/R/library\n\n──────────────────────────────────────────────────────────────────────────────\n```\n\n\n:::\n:::\n",
    "supporting": [
      "01_networks_in_data_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}