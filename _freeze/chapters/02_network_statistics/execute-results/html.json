{
  "hash": "c11d8b1fb64d7127e6f33cf62173191b",
  "result": {
    "engine": "knitr",
    "markdown": "---\nexecute: \n  warning: false\n---\n\n\n# Network statistics\n\nIn this lesson, you will learn to perform descriptive analyses of networks,\nincluding calculation of network statistics, and community detection.\nAt the end of this lesson, you will be able to:\n\n- understand and calculate the main network-, node-, and edge-level statistics;\n- identify communities (or clusters) in networks using different algorithms;\n- assess network cohesion.\n\nLet's start by loading the packages we will use.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123) # for reproducibility\n\n# Load required packages\nlibrary(here)\nlibrary(tidyverse)\nlibrary(igraph)\nlibrary(igraphdata)\n```\n:::\n\n\n## Node-level statistics\n\nIn a graph, some nodes are thought to be more important than others. However,\n\"important\" is a quite subjective term, so we need formal ways of measuring how \ncentral a node is in a network. These metrics are often referred to as \n*centrality measures*. There are many of such metrics, but some of the most\ncommonly used are:\n\n1. **Degree:** number of connections of a node *N*. In weighted graphs,\nthis is usually measured as the sum of weights of the edges containing \nnode *N*. In directed graphs, we often distinguish \nbetween **in-degree** (number of ingoing edges) and **out-degree** (number\nof outgoing edges).\n\n2. **Closeness:** the average length of the shortest path between a node *N*\nand all other nodes in the graph.\n\n3. **Betweenness:** the number of shortest paths going through a node,\nwhich quantifies the number of times a node acts as a bridge along the\nshortest path between two other nodes.\n\n4. **Eigenvector centrality:** first eigenvector of the graph's adjacency\nmatrix.\n\n5. **Harmonic centrality:** the mean inverse distance of a node *N* to all\nother nodes.\n\nTo demonstrate how to calculate these node statistics, consider the following\ngraph:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng <- make_graph(\"Krackhardt kite\")\nplot(g)\n```\n\n::: {.cell-output-display}\n![](02_network_statistics_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\nLet's calculate different centrality measures:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Degree\nc1 <- degree(g)\n\n# Closeness\nc2 <- closeness(g)\n\n# Betweenness\nc3 <- betweenness(g)\n\n# Eigenvector centrality\nc4 <- eigen_centrality(g)$vector\n\n# Harmonic centrality\nc5 <- harmonic_centrality(g)\n\n# Show all measures\ncentrality_summary <- data.frame(\n    node = as.character(V(g)),\n    degree = c1,\n    closeness = c2,\n    betweenness = c3,\n    eigenvector = c4,\n    harmonic = c5\n)\n\ncentrality_summary\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   node degree  closeness betweenness eigenvector harmonic\n1     1      4 0.05882353   0.8333333  0.73221232 6.083333\n2     2      4 0.05882353   0.8333333  0.73221232 6.083333\n3     3      3 0.05555556   0.0000000  0.59422577 5.583333\n4     4      6 0.06666667   3.6666667  1.00000000 7.083333\n5     5      3 0.05555556   0.0000000  0.59422577 5.583333\n6     6      5 0.07142857   8.3333333  0.82676381 6.833333\n7     7      5 0.07142857   8.3333333  0.82676381 6.833333\n8     8      3 0.06666667  14.0000000  0.40717690 6.000000\n9     9      2 0.04761905   8.0000000  0.09994054 4.666667\n10   10      1 0.03448276   0.0000000  0.02320742 3.416667\n```\n\n\n:::\n:::\n\n\nNote how the \"most important\" node in the graph changes depending on the\ncentrality measure used. This example nicely illustrates the importance of \nusing different centrality measures to assess a node's importance in a graph. \n\n::: {.callout-tip}\n\n### Practice\n\nUse the code below to load an `igraph` object containing character \nrelationships in the TV show \"Game of Thrones\". Then, answer the questions\nbelow using this graph.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load Game of Thrones network\ngot <- readRDS(here(\"data\", \"got.rds\"))\n```\n:::\n\n\n1. Calculate the *degree*, *closeness*, *betweenness*, *eigenvector*, and\n*harmonic* centralities of all nodes in this network. Which character\nis the most central based on each of these measures?\n\n2. In network science, people often want to find hubs, which are the most\nhighly connected nodes in a graph. Here, we will define as hubs the \ntop 10% most highly connected nodes. Based on this definition, identify\nhubs in the `got` network.\n\n::: {.callout appearance=\"minimal\" collapse=\"true\"}\n\n### Show me the solutions\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Q1\ngot_centrality <- data.frame(\n    degree = degree(got),\n    closeness = closeness(got),\n    betweenness = betweenness(got),\n    eigenvector = eigen_centrality(got)$vector,\n    harmonic = harmonic_centrality(got)\n)\n\napply(got_centrality, 2, which.max)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     degree   closeness betweenness eigenvector    harmonic \n          7           7           6           7           7 \n```\n\n\n:::\n\n```{.r .cell-code}\n# Q2\ndeg <- sort(degree(got), decreasing = TRUE)\ndeg[seq_len(length(deg) * 0.1)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n Tyrion     Jon   Sansa    Robb   Jaime   Tywin  Cersei    Arya  Robert Joffrey \n     36      26      26      25      24      22      20      19      18      18 \n```\n\n\n:::\n:::\n\n\n:::\n:::\n\n## Edge-level statistics\n\nIn network science, researchers usually can answer their questions by\nexploring node statistics. However, some questions can only be answered\nby analyzing edge statistics. For example, one might be interested in\nknowing which connections are more important for the flow of information\n(in social networks) or a molecular signal (in molecular networks). \n\n\nThe most common edge-level statistic is the **edge betweenness**, which is \nan extension of node betweenness describing the number of shortest paths\ntraversing an edge *E*. Let's calculate edge betweenness for all egdes in the\ngraph we created before.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculate edge betweenness\nedge_betweenness(g)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  2.666667  1.500000  1.833333  4.666667  1.833333  1.500000  4.666667\n [8]  3.000000  4.500000  3.000000  3.333333  3.333333  4.500000  2.666667\n[15] 10.500000 10.500000 16.000000  9.000000\n```\n\n\n:::\n:::\n\n\nIf you want to extract edges that have the highest betweenness, you'd do\nthe following:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Extract edges with the highest betweenness centrality\neb <- edge_betweenness(g)\nas_edgelist(g)[which.max(eb), ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 8 9\n```\n\n\n:::\n:::\n\n\nWhile the betweenness centrality can be extended to edges, other node \ncentrality measures do not. One way to circumvent this is to create \na **line graph** of a graph *G*, and then calculate centrality measures\nfor the nodes of the line graph. A line graph of *G*, *G' = (V', E')*,\nis obtained by changing the nodes of a graph to edges, and edges to nodes.\nYou can do that with __igraph__ using the function `make_line_graph()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Obtaining the line graph G' of a graph G\nlg <- make_line_graph(g)\nlg\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nIGRAPH 3c8919f U--- 18 57 -- Line graph\n+ attr: name (g/c)\n+ edges from 3c8919f:\n [1]  1-- 2  1-- 3  2-- 3  1-- 4  2-- 4  3-- 4  3-- 5  1-- 5  1-- 6  5-- 6\n[11]  1-- 7  5-- 7  6-- 7  3-- 8  5-- 8  2-- 8  4-- 9  2-- 9  8-- 9  6--10\n[21]  3--10  5--10  8--10  4--11  9--11  3--11  5--11  8--11 10--11  7--12\n[31]  3--12  5--12  8--12 10--12 11--12  7--13 12--13  6--13 10--13  7--14\n[41] 12--14 13--14  4--14  9--14 11--14  4--15  9--15 11--15 14--15 15--16\n[51]  7--16 12--16 13--16 14--16 15--17 16--17 17--18\n```\n\n\n:::\n:::\n\n\nOnce you have the line graph of a graph *G*, you can calculate node centrality\nmeasures as described in the previous section (e.g., degree, closeness, etc.).\nSince nodes and edges have been swapped, node statistics of a line graph\nactually describe edge statistics of the original graph.\n\n::: {.callout-tip}\n\n### Practice\n\nUsing the Game of Thrones graph from the previous practice problems,\nanswer the questions below:\n\n1. Which edges have the highest betweenness?\n\n2. Create the line graph of this graph and calculate the degree, betweenness, \nand closeness of the line graph. Are the nodes with the highest values for\neach of these measures the same?\n\n::: {.callout appearance=\"minimal\" collapse=\"true\"}\n\n### Show me the solutions\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Q1\neb <- edge_betweenness(got)\nas_edgelist(got)[which.max(eb), ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Robert\"   \"Daenerys\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Q2\nlgot <- make_line_graph(got)\nmax_degree <- which.max(degree(lgot))\nmax_closeness <- which.max(closeness(lgot))\nmax_betweenness <- which.max(betweenness(lgot))\n\nlist(max_degree, max_closeness, max_betweenness)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 289\n\n[[2]]\n[1] 243\n\n[[3]]\n[1] 90\n```\n\n\n:::\n:::\n\n\n:::\n:::\n\n\n\n## Assessing network cohesion\n\nNetwork cohesion refers to the extent to which subsets of nodes are\ncohesive with respect to the relation defining edges in the graph. In\nmolecular biology, for example, assessing network cohesion can reveal what\nproteins seem to work closely together in a cell; in social networks, one\ncan investigate whether friends of person A tend to be friends of person B\nas well. There are many ways of assessing network cohesion, and we will\nexplore the most common ones in the sections below.\n\n### Subgraphs and censuses\n\nA popular way of defining network cohesion consists in analyzing frequencies\nof particular types of subgraphs. One of the most remarkable subgraphs\nis the **clique**, which are complete subgraphs (all nodes are connected\nby edges). Using the karate club network, let's count the frequency of cliques\nof each size.\n\nCliques and maximal cliques\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create karate club graph\ng <- make_graph(\"Zachary\")\n\n# Count frequency of cliques of each size\ntable(lengths(cliques(g)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n 1  2  3  4  5 \n34 78 45 11  2 \n```\n\n\n:::\n:::\n\n\nCliques of size 1 and 2 indicate nodes and edges, respectively, so they\nare are usually ignored when assessing network cohesion. Ignoring those,\nthe table above shows that most of the cliques (N = 45) are triangles (size\nthree), and the maximum clique size is 5.\n\nHowever, note that larger cliques can include smaller cliques, leading\nto some sort of redundancy. Because of that, it is often interesting\nto identify **maximal cliques**, which are defined as cliques that are not\na subset of a larger clique. Let's now count the frequency of maximal cliques.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Count the frequency of maximal cliques of each size\ntable(lengths(max_cliques(g)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n 2  3  4  5 \n11 21  2  2 \n```\n\n\n:::\n:::\n\n\nBesides cliques, other important types of subgraphs include dyads (pairs\nof nodes) and triads (triples of nodes), especially in directed graphs. \nIn directed graphs, dyads can take on three possible states:\nnull (no directed edge), assymetric (one directed edge), or mutual (two\ndirected edges). Likewise, triads can take on 16 possible states. \n\nTo perform a census of the possible states of dyads and triads, you can use \nthe functions `dyad_census()` and `triad_census()`, respectively. Let's \ndemonstrate it with the `enron` email network (emails generated by 500k \nemployees of the Enron Corporation).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load data set\ndata(enron)\n\n# Get dyad census (frequency of dyad states)\ndyad_census(enron)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$mut\n[1] 913\n\n$asym\n[1] 1184\n\n$null\n[1] 14739\n```\n\n\n:::\n:::\n\n\nIn this data set, we can see that, among non-null states, most dyads are\nassymetric.\n\n\nFinally, **motifs** are another commonly studied type of subgraph,\nespecially in biological networks, and they are defined as small \nconnected subgraphs that appear more often than the expected by chance. \nBelow is an example of how to count motifs of size 3.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get frequecy of motifs of size 3\nmotifs(g, size = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  NA  NA 393  45\n```\n\n\n:::\n:::\n\n\nThe order of the motifs is defined by their isomorphism class (see\n`?isomophism_class` for details). Note that unconnected subgraphs are not \nconsidered to be motifs, so their frequencies will be result in NA.\n\n### Relative frequency-based measures\n\nA common measure of network cohesion is the **density** of a graph, which\ndescribes the frequency of existing edges relative to the potential number\nof edges. This is a number that ranges between 0 and 1, and it can\nbe estimated with the function `edge_density()`. Let's demonstrate it\nby calculating the density of the entire graph for the karate club network,\nand for a subgraph containing only one of the instructors and its first-order\nneighbors\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculate density of the entire graph\nedge_density(g)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.1390374\n```\n\n\n:::\n\n```{.r .cell-code}\n# Calculate density of subgraph containing instructor (node 24) and neighbors\nsg <- induced_subgraph(g, neighborhood(g, 1, 34)[[1]])\nedge_density(sg)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.2091503\n```\n\n\n:::\n:::\n\n\nA somewhat similar measure is the **clustering coefficient**, which describes\nthe number of connected triples that close to form triangles. This measure\nis also referred to as **transitivity**, which is why the __igraph__ function \nto calculate it is called `transitivity()`. To calculate the clustering\ncoefficient of the entire graph, you'd do as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculate clustering coefficient of the graph\ntransitivity(g)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.2556818\n```\n\n\n:::\n:::\n\n\n\nFinally, another measure that only applies to *directed graphs* is the\n**reciprocity** of a graph, which defines the number of dyads with reciprocated\n(i.e., mutual) directed egdes divided by the number of dyads with a single,\nunreciprocated edge. Let's calculate the reciprocity of the `enron` network.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculate reciprocity of the `enron` network\nreciprocity(g)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n:::\n\n\n### Connectivity and cuts\n\nResearchers usually want to find out whether a graph separates into distinct\nsubgraphs. In this context, a graph is said to be *connected* if every node \nis reachable from every other. To find out if a graph is connected,\nyou can use the function `is_connected()`. Let's demonstrate it in a network\nof protein-protein interactions in yeast (N = 2617 nodes).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load yeast protein-protein interaction network\ndata(yeast)\n\n# Check if the network is connected\nis_connected(yeast)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\nThe fact that the network is not connected means that this large graph is \nbroken into components. In such graphs, it often happens that one of these \ncomponents is much larger than all the others, and this is called \nthe **giant component**. To investigate if the `yeast` network contains a giant\ncomponent, let's decompose this graph into different components and count the \nnumber of nodes per component.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Decompose the graph and count number of nodes in each component\ncomps <- decompose(yeast)\ntable(lengths(comps))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n   2    3    4    5    6    7 2375 \n  63   13    5    6    1    3    1 \n```\n\n\n:::\n:::\n\n\nWe can see that there's a single component with 2735 nodes (~90% of the total\nnumber of nodes), while other components have very few nodes. When this is the\ncase, it is common practice to restrict further analyses to the giant component\nonly, as the other smaller components are not very informative. Let's extract\nthe giant component.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Extract giant component\nyeast_gc <- decompose(yeast)[[1]]\n```\n:::\n\n\nGiant components usually display a remarkable characteristic termed \n**small world** property, which means that the average shortest-path distance\nis small, but clustering coefficient is high. Let's check if this is the case\nhere:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get average path length and diameter\nmean_distance(yeast_gc)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5.09597\n```\n\n\n:::\n\n```{.r .cell-code}\ndiameter(yeast_gc)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 15\n```\n\n\n:::\n\n```{.r .cell-code}\n# Get clustering coefficient\ntransitivity(yeast_gc)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.4686663\n```\n\n\n:::\n:::\n\n\nIndeed, this giant component has a small average shortest-path distance, and\nrelatively high clustering coefficient.\n\nIn a graph, there are usually some nodes that, if removed, can disconnect the\ngraph. These are called **articulation points** or **cut nodes**, and they\ntypically indicate parts of a network that are vulnerable to attacks.\nYou can identify them with the function `articulation_points()` as below:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get articulation points\nap <- articulation_points(yeast_gc)\nlength(ap)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 350\n```\n\n\n:::\n:::\n\n\nIn the giant component of the yeast network, 350 nodes are articulation points.\n\n::: {.callout-tip}\n\n### Practice\n\nUsing the Game of Thrones graph from the previous practice problems, answer\nthe questions below.\n\n1. How many cliques of each size are there? What is the size of the largest\nclique?\n\n2. How many maximal cliques of each size are there? What is the size of the\nlargest maximal clique?\n\n3. What is the network's density and clustering coefficient?\n\n4. If this network connected?\n\n5. What is the network's average shortest-path distance and diameter?\n\n6. How many articulation points are there? What percentage of the total number\nof nodes does that represent?\n\n::: {.callout appearance=\"minimal\" collapse=\"true\"}\n\n### Show me the solutions\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Q1\ngcl <- cliques(got)\ntable(lengths(gcl))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n  1   2   3   4   5   6   7 \n107 352 469 330 124  22   1 \n```\n\n\n:::\n\n```{.r .cell-code}\n# Q2\nmgcl <- max_cliques(got)\ntable(lengths(mgcl))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n 2  3  4  5  6  7 \n22 24 44 30 15  1 \n```\n\n\n:::\n\n```{.r .cell-code}\n# Q3\nedge_density(got)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.06207018\n```\n\n\n:::\n\n```{.r .cell-code}\ntransitivity(got)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.3286615\n```\n\n\n:::\n\n```{.r .cell-code}\n# Q4\nis_connected(got)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n# Q5\nmean_distance(got)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 22.06366\n```\n\n\n:::\n\n```{.r .cell-code}\ndiameter(got)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 85\n```\n\n\n:::\n\n```{.r .cell-code}\n# Q6\narticulation_points(got)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n+ 11/107 vertices, named, from f76bd92:\n [1] Oberyn   Davos    Kevan    Bran     Robb     Belwas   Daenerys Tyrion  \n [9] Jaime    Craster  Jon     \n```\n\n\n:::\n\n```{.r .cell-code}\nlength(articulation_points(got)) / vcount(got)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.1028037\n```\n\n\n:::\n:::\n\n\n:::\n:::\n\n## Community detection\n\nIdentifying communities or clusters in a graph is one of the most common\nanalyses in network science. This is a way of identifying subgraphs\ncontaining more closely-related nodes, and it has many implications in\ndifferent fields. In biology, for instance, this can be used to identify\ngenes or proteins involved in the same biological process; in social\nnetwork science, this can reveal individuals that share traits and/or \ninterests.\n\nIn __igraph__, you can identify communities using a family of functions named\n`cluster_*()`, and each function detects communities using a different\nalgorithm. The Infomap algorithm is arguably one of the most popular of them,\nand it's available in the function `cluster_infomap()`. Let's demonstrate it.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create graph\ng <- make_graph(\"Zachary\")\nplot(g)\n```\n\n::: {.cell-output-display}\n![](02_network_statistics_files/figure-html/unnamed-chunk-23-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# Detect communities with Infomap\ncl <- cluster_infomap(g)\ncl\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nIGRAPH clustering infomap, groups: 3, mod: 0.4\n+ groups:\n  $`1`\n   [1]  1  2  3  4  8 10 12 13 14 18 20 22\n  \n  $`2`\n  [1]  5  6  7 11 17\n  \n  $`3`\n   [1]  9 15 16 19 21 23 24 25 26 27 28 29 30 31 32 33 34\n  \n```\n\n\n:::\n:::\n\n\nIn the output of `cluster_infomap()`, we can observe that the Infomap algorithm\nidentified 3 clusters, whose members are described below each cluster ID.\nYou can also extract cluster membership for each node with the functions\n`membership()` and `communities()`, which return a vector or membership and a\nlist, respectively.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Vector of cluster membership for each node\nmembership(cl)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 1 1 1 1 2 2 2 1 3 1 2 1 1 1 3 3 2 1 3 1 3 1 3 3 3 3 3 3 3 3 3 3 3 3\n```\n\n\n:::\n\n```{.r .cell-code}\n# List of nodes that belong to each cluster\ncommunities(cl)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$`1`\n [1]  1  2  3  4  8 10 12 13 14 18 20 22\n\n$`2`\n[1]  5  6  7 11 17\n\n$`3`\n [1]  9 15 16 19 21 23 24 25 26 27 28 29 30 31 32 33 34\n```\n\n\n:::\n:::\n\n\nThe generic `plot()` function can also be used to quickly visualize\nthe graph with clusters highlighted.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Visualize graph with communities highlighted\nplot(cl, g)\n```\n\n::: {.cell-output-display}\n![](02_network_statistics_files/figure-html/unnamed-chunk-25-1.png){width=672}\n:::\n:::\n\n\nIf you have communities detected with different algorithms, you can use\nthe function `compare()` to calculate the distance between two community\nstructures. To demonstrate, let's detect communities using another\nvery popular algorithm named Louvain.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Detect community with Louvain\ncl2 <- cluster_louvain(g)\n\n# Compare community structures\ncompare(cl, cl2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.2727973\n```\n\n\n:::\n:::\n\n\nThe function `compare()` can calculate distances between community\nstructures using different methods. For more details on all methods, see\nthe function's help page (with `?compare`).\n\n::: {.callout-tip}\n\n### Practice\n\nUsing the Game of Thrones graph from the previous practice problems,\nidentify communities using the Infomap, Louvain, Leiden, and \nlabel propagation algorithms. Then, answer the questions below.\n\n1. How many clusters were detected by each algorithm?\n\n2. Calculate the distance between the community structures detected with \nInfomap and all other methods. What do you conclude based on the results?\n\n\n::: {.callout appearance=\"minimal\" collapse=\"true\"}\n\n### Show me the solutions\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Q1\nclist <- list(\n    Infomap = cluster_infomap(got),\n    Louvain = cluster_louvain(got),\n    Leiden = cluster_leiden(got),\n    Label_prop = cluster_label_prop(got)\n)\n\nlengths(clist)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Infomap    Louvain     Leiden Label_prop \n         7          7         31          8 \n```\n\n\n:::\n\n```{.r .cell-code}\n# Q2\nlist(\n    compare(clist$Infomap, clist$Louvain),\n    compare(clist$Infomap, clist$Leiden),\n    compare(clist$Infomap, clist$Label_prop)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 0\n\n[[2]]\n[1] 0.9703974\n\n[[3]]\n[1] 0.1900617\n```\n\n\n:::\n:::\n\n\n:::\n:::\n\n\n## Session information {.unnumbered}\n\nThis chapter was created under the following conditions:\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.2 (2023-10-31)\n os       Ubuntu 22.04.3 LTS\n system   x86_64, linux-gnu\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       Europe/Brussels\n date     2024-04-19\n pandoc   3.1.1 @ /usr/lib/rstudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package     * version date (UTC) lib source\n cli           3.6.2   2023-12-11 [1] CRAN (R 4.3.2)\n colorspace    2.1-0   2023-01-23 [1] CRAN (R 4.3.2)\n digest        0.6.34  2024-01-11 [1] CRAN (R 4.3.2)\n dplyr       * 1.1.4   2023-11-17 [1] CRAN (R 4.3.2)\n evaluate      0.23    2023-11-01 [1] CRAN (R 4.3.2)\n fansi         1.0.6   2023-12-08 [1] CRAN (R 4.3.2)\n fastmap       1.1.1   2023-02-24 [1] CRAN (R 4.3.2)\n forcats     * 1.0.0   2023-01-29 [1] CRAN (R 4.3.2)\n generics      0.1.3   2022-07-05 [1] CRAN (R 4.3.2)\n ggplot2     * 3.5.0   2024-02-23 [1] CRAN (R 4.3.2)\n glue          1.7.0   2024-01-09 [1] CRAN (R 4.3.2)\n gtable        0.3.4   2023-08-21 [1] CRAN (R 4.3.2)\n here        * 1.0.1   2020-12-13 [1] CRAN (R 4.3.2)\n hms           1.1.3   2023-03-21 [1] CRAN (R 4.3.2)\n htmltools     0.5.7   2023-11-03 [1] CRAN (R 4.3.2)\n htmlwidgets   1.6.4   2023-12-06 [1] CRAN (R 4.3.2)\n igraph      * 2.0.1.1 2024-01-30 [1] CRAN (R 4.3.2)\n igraphdata  * 1.0.1   2015-07-13 [1] CRAN (R 4.3.2)\n jsonlite      1.8.8   2023-12-04 [1] CRAN (R 4.3.2)\n knitr         1.45    2023-10-30 [1] CRAN (R 4.3.2)\n lifecycle     1.0.4   2023-11-07 [1] CRAN (R 4.3.2)\n lubridate   * 1.9.3   2023-09-27 [1] CRAN (R 4.3.2)\n magrittr      2.0.3   2022-03-30 [1] CRAN (R 4.3.2)\n munsell       0.5.0   2018-06-12 [1] CRAN (R 4.3.2)\n pillar        1.9.0   2023-03-22 [1] CRAN (R 4.3.2)\n pkgconfig     2.0.3   2019-09-22 [1] CRAN (R 4.3.2)\n purrr       * 1.0.2   2023-08-10 [1] CRAN (R 4.3.2)\n R6            2.5.1   2021-08-19 [1] CRAN (R 4.3.2)\n readr       * 2.1.5   2024-01-10 [1] CRAN (R 4.3.2)\n rlang         1.1.3   2024-01-10 [1] CRAN (R 4.3.2)\n rmarkdown     2.25    2023-09-18 [1] CRAN (R 4.3.2)\n rprojroot     2.0.4   2023-11-05 [1] CRAN (R 4.3.2)\n rstudioapi    0.15.0  2023-07-07 [1] CRAN (R 4.3.2)\n scales        1.3.0   2023-11-28 [1] CRAN (R 4.3.2)\n sessioninfo   1.2.2   2021-12-06 [1] CRAN (R 4.3.2)\n stringi       1.8.3   2023-12-11 [1] CRAN (R 4.3.2)\n stringr     * 1.5.1   2023-11-14 [1] CRAN (R 4.3.2)\n tibble      * 3.2.1   2023-03-20 [1] CRAN (R 4.3.2)\n tidyr       * 1.3.1   2024-01-24 [1] CRAN (R 4.3.2)\n tidyselect    1.2.0   2022-10-10 [1] CRAN (R 4.3.2)\n tidyverse   * 2.0.0   2023-02-22 [1] CRAN (R 4.3.2)\n timechange    0.3.0   2024-01-18 [1] CRAN (R 4.3.2)\n tzdb          0.4.0   2023-05-12 [1] CRAN (R 4.3.2)\n utf8          1.2.4   2023-10-22 [1] CRAN (R 4.3.2)\n vctrs         0.6.5   2023-12-01 [1] CRAN (R 4.3.2)\n withr         3.0.0   2024-01-16 [1] CRAN (R 4.3.2)\n xfun          0.42    2024-02-08 [1] CRAN (R 4.3.2)\n yaml          2.3.8   2023-12-11 [1] CRAN (R 4.3.2)\n\n [1] /home/faalm/R/x86_64-pc-linux-gnu-library/4.3\n [2] /usr/local/lib/R/site-library\n [3] /usr/lib/R/site-library\n [4] /usr/lib/R/library\n\n──────────────────────────────────────────────────────────────────────────────\n```\n\n\n:::\n:::\n",
    "supporting": [
      "02_network_statistics_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}