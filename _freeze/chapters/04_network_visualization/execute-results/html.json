{
  "hash": "13e381256ba9a0e72aff798155d7a900",
  "result": {
    "engine": "knitr",
    "markdown": "---\nexecute: \n  warning: false\n  eval: true\nknitr:\n    opts_chunk: \n      fig.align: center\n---\n\n\n# Network visualization\n\nIn this lesson, you will learn how to visualize networks using the\nggplot plotting system. At the end of this lesson, you will be able to:\n\n- convert `igraph` objects to their *tidy* representation;\n- identify which network layout to use for each kind of network data;\n- modify aesthetic properties of nodes and edges;\n- enhance visualizations for large graphs.\n\nLet's start by loading the packages we will use.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nset.seed(123) # for reproducibility\n\n# Load required packages\nlibrary(here)\nlibrary(igraph)\nlibrary(igraphdata)\nlibrary(tidyverse)\nlibrary(tidygraph)\nlibrary(ggraph)\nlibrary(patchwork)\n\nset_graph_style(plot_margin = margin(1,1,1,1))\n```\n:::\n\n\n## Tidy graph representations\n\nTo create plots using the ggplot plotting system, one needs to have tidy data\nin the long format (as in the tidyverse nomenclature), which is summarized\nbelow.\n\n![](tidydata.jpg){fig-align=\"center\"}\n\nTo convert `igraph` objects to a tidy data frame, you can use \nthe *[tidygraph](https://CRAN.R-project.org/package=tidygraph)* package, which offers a tidy API\nfor graph manipulation. In particular, we are mostly interested in the function\n`as_tbl_graph`, which converts `igraph` objects to `tbl_graph` objects\ncontaining nodes and edges (with attributes, if any) in a tidy format. Let's\ndemonstrate it with the karate network we've been using in previous chapters.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Get karate club network\ng <- make_graph(\"Zachary\")\n\n# Convert `igraph` object to tidy `tbl_graph`\ngraph_df <- as_tbl_graph(g)\n\ngraph_df\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tbl_graph: 34 nodes and 78 edges\n#\n# An undirected simple graph with 1 component\n#\n# Node Data: 34 × 0 (active)\n#\n# Edge Data: 78 × 2\n   from    to\n  <int> <int>\n1     1     2\n2     1     3\n3     1     4\n# ℹ 75 more rows\n```\n\n\n:::\n:::\n\n\nWe can see that this `tbl_graph` object contains only edge information,\nbecause the original `igraph` object does not contain node attributes.\nFor example, let's now do the same with the `macaque` network data from the\n*[igraphdata](https://CRAN.R-project.org/package=igraphdata)* package.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndata(macaque)\n\n# Convert `igraph` object to tidy `tbl_graph`\nmacaque_df <- as_tbl_graph(macaque)\n\nmacaque_df\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tbl_graph: 45 nodes and 463 edges\n#\n# A directed simple graph with 1 component\n#\n# Node Data: 45 × 2 (active)\n   shape  name  \n   <chr>  <chr> \n 1 square V1    \n 2 square V2    \n 3 square V3    \n 4 square V3A   \n 5 square V4    \n 6 square V4t   \n 7 square VOT   \n 8 square VP    \n 9 square MT    \n10 square MSTd/p\n# ℹ 35 more rows\n#\n# Edge Data: 463 × 2\n   from    to\n  <int> <int>\n1     1     2\n2     1     3\n3     1     4\n# ℹ 460 more rows\n```\n\n\n:::\n:::\n\n\n## Plotting networks\n\nThe *[ggraph](https://CRAN.R-project.org/package=ggraph)* package is arguably one of the most\npopular R packages to visualize networks using the ggplot system. This\npackage was designed to interoperate with *[tidygraph](https://CRAN.R-project.org/package=tidygraph)*,\nand it can produce network visualizations from `tbl_graph` objects \nin many ways. In the sections below, we will explore the building blocks\nof plots produced with __ggraph__.\n\n### Layouts\n\nWhen plotting networks, a very important step consists in choosing an \nappropriate layout to use. Layouts algorithms are algorithms that take \na graph structure and return the x and y coordinates of the nodes.\n\nTo start, let's create a basic network plot using the `highschool` data set,\nwhich contains friendship relationships among high school boys in 1957\nand 1958. We will use the default layout.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Create `tbl_graph` object\ngdf <- as_tbl_graph(highschool)\n\nggraph(gdf) +\n    geom_edge_link(aes(color = factor(year))) +\n    geom_node_point()\n```\n\n::: {.cell-output-display}\n![](04_network_visualization_files/figure-html/unnamed-chunk-4-1.png){fig-align='center' width=672}\n:::\n:::\n\n\nBy default, the function `ggraph()` uses the \"stress\" layout, a slightly \nmodified version of the stress-minimization algorithm Kamada-Kawai.\nHowever, `ggraph()` offers multiple layout algorithms, including\ninternal __igraph__ layout algorithms (available in __igraph__'s functions\n`layout_with_*()`). You can explore all available layouts by running\n`?create_layout()`.\n\nDifferent layout algorithms can be specified in the `layout` argument of the\n`ggraph()` function. For example, let's recreate the network plot above, but\nnow with the **'kk'** layout (internal igraph layout).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggraph(gdf, layout = \"kk\") +\n    geom_edge_link(aes(color = factor(year))) +\n    geom_node_point()\n```\n\n::: {.cell-output-display}\n![](04_network_visualization_files/figure-html/unnamed-chunk-5-1.png){fig-align='center' width=672}\n:::\n:::\n\n\nIf you look at the documentation of the function `igraph::layout_with_kk()`,\nyou will notice that this layout algorithm can take additional parameters (as\ndo most layout algorithms). These additional parameters can be passed \nto `ggraph()` as well.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggraph(gdf, layout = \"kk\", maxiter = 100) +\n    geom_edge_link(aes(color = factor(year))) +\n    geom_node_point()\n```\n\n::: {.cell-output-display}\n![](04_network_visualization_files/figure-html/unnamed-chunk-6-1.png){fig-align='center' width=672}\n:::\n:::\n\n\nAlternatively, you can also use the function `create_layout()` to get\na data frame of x and y coordinates for nodes based on a specific layout\nalgorithm. Under the hood, this is what `ggraph()` does.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Get a data frame of x and y coordinates based on layout 'kk'\ncoords <- create_layout(gdf, layout = \"kk\")\n\nhead(coords)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 5\n       x     y .ggraph.orig_index circular .ggraph.index\n   <dbl> <dbl>              <int> <lgl>            <int>\n1  2.34  1.34                   1 FALSE                1\n2  2.72  1.84                   2 FALSE                2\n3  3.32  1.31                   3 FALSE                3\n4 -2.54  0.884                  4 FALSE                4\n5 -1.76  1.95                   5 FALSE                5\n6 -0.357 3.33                   6 FALSE                6\n```\n\n\n:::\n\n```{.r .cell-code}\n# Plot network using the data frame of coordinates\nggraph(coords) + \n  geom_edge_link(aes(color = factor(year))) + \n  geom_node_point()\n```\n\n::: {.cell-output-display}\n![](04_network_visualization_files/figure-html/unnamed-chunk-7-1.png){fig-align='center' width=672}\n:::\n:::\n\n\n__ggraph__ includes all layouts in the packages *[igraph](https://CRAN.R-project.org/package=igraph)*\nand *[graphlayouts](https://CRAN.R-project.org/package=graphlayouts)*, as well as specialized layouts\nthat are only available in __ggraph__. We will explore some layout options\nin the subsections below.\n\n::: {.callout-tip}\n\n### Practice\n\n1. Using the `macaque` network, create a network plot that matches the \nfollowing requirements:\n\n- Layout: 'kk'\n- Edge color: 'gray80'\n- Node color and shape should be mapped to node attribute **shape**.\n\n*Hint:* mapping variables to plot aesthetics works just like in any other\nplot created with the ggplot system.\n\n\n2. Recreate the same plot as above, but now using the layouts 'graphopt',\n'circle', and 'fr'.\n\n::: {.callout appearance=\"minimal\" collapse=\"true\"}\n\n### Show me the solutions\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ng <- as_tbl_graph(macaque)\n\n# Q1\nggraph(g, layout = \"kk\") +\n    geom_edge_link(color = \"gray80\") +\n    geom_node_point(aes(shape = shape, color = shape))\n```\n\n::: {.cell-output-display}\n![](04_network_visualization_files/figure-html/unnamed-chunk-8-1.png){fig-align='center' width=672}\n:::\n\n```{.r .cell-code}\n# Q2\nggraph(g, layout = \"graphopt\") +\n    geom_edge_link(color = \"gray80\") +\n    geom_node_point(aes(shape = shape, color = shape))\n```\n\n::: {.cell-output-display}\n![](04_network_visualization_files/figure-html/unnamed-chunk-8-2.png){fig-align='center' width=672}\n:::\n\n```{.r .cell-code}\nggraph(g, layout = \"circle\") +\n    geom_edge_link(color = \"gray80\") +\n    geom_node_point(aes(shape = shape, color = shape))\n```\n\n::: {.cell-output-display}\n![](04_network_visualization_files/figure-html/unnamed-chunk-8-3.png){fig-align='center' width=672}\n:::\n\n```{.r .cell-code}\nggraph(g, layout = \"fr\") +\n    geom_edge_link(color = \"gray80\") +\n    geom_node_point(aes(shape = shape, color = shape))\n```\n\n::: {.cell-output-display}\n![](04_network_visualization_files/figure-html/unnamed-chunk-8-4.png){fig-align='center' width=672}\n:::\n:::\n\n\n:::\n:::\n\n\n#### Circular layouts\n\nSome relationships in network data are better visualized if represented\nin a circular fashion You can create circular representations by \nsetting `circular = TRUE` in `ggraph()`. To demonstrate, let's create the\nsame kind of network plot, an **arc diagram**, in standard and circular layout.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# 1) Arc diagram - standard representation\np1 <- ggraph(gdf, layout = 'linear') + \n  geom_edge_arc(aes(colour = factor(year)))\n\n# 2) Chord diagram - circular representation\np2 <- ggraph(gdf, layout = 'linear', circular = TRUE) + \n  geom_edge_arc(aes(colour = factor(year)))\n\np1 / p2\n```\n\n::: {.cell-output-display}\n![](04_network_visualization_files/figure-html/unnamed-chunk-9-1.png){fig-align='center' width=480}\n:::\n:::\n\n\nYou may have noticed that the network layout (and everything else) remains\nthe same in both plots, and the only difference is that the second plot was \ncreated by representing the layout in a circular fashion. Note also that\nrepresenting a layout circularly often changes the \"name\" of the visualization\n(i.e., how people often refer to it). In this example, you can clearly see\nthat a so-called **chord diagram** is simply an **arc diagram** represented\ncircularly.\n\nAnother example of how circular representations can change a visualization's \n\"name\" is the distinction between **icicle plots** and **sunburst plots**,\nboth of which represent hierarchical data, but latter method does so\nin a circular fashion. To demonstrate, let's create both plots using \nthe `flare` data set, which contains a graph describing the class hierarchy\nfor the Flare ActionScript visualization library.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Create `tbl_graph` object from flare data set\nfg <- tbl_graph(flare$vertices, flare$edges)\n\n# 1) Icicle plot - standard representation\np1 <- ggraph(fg, \"partition\") +\n    geom_node_tile(aes(fill = depth), linewidth = 0.2)\n\n# 1) Sunburst plot - standard representation\np2 <- ggraph(fg, \"partition\", circular = TRUE) +\n    geom_node_arc_bar(aes(fill = depth), linewidth = 0.2) +\n    coord_fixed()\n\np1 + p2\n```\n\n::: {.cell-output-display}\n![](04_network_visualization_files/figure-html/unnamed-chunk-10-1.png){fig-align='center' width=768}\n:::\n:::\n\n\n#### Node-edge layouts\n\nWhen people think about network visualizations, node-edge diagrams are arguably\nthe first picture that comes to their mind. __igraph__ offers many layout \nalgorithms to create such plots, each of them optimized for a different\nscenario. Thus, there is no such thing as \"the best layout algorithm\", and\nyou should try different algorithms for your network to see what looks better.\n\nTo demonstrate some of these family of algorithms and how you can explore\nhow the plots they create look like, we will store layout names in a vector\nand loop through them, passing them as input to the `layout` argument\nof `ggraph()` in each iteration. Recall that this is possible because\ndifferent layouts can be used by simply changing the input to the `layout` \nargument.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Define layout names we want to try\nlayouts <- c(\"stress\", \"fr\", \"lgl\", \"graphopt\")\n\n# Create the same plot, but changing input to `layout` argument\nplots <- lapply(layouts, function(x) {\n    \n    p <- ggraph(highschool, layout = x) + \n        geom_edge_link(aes(colour = factor(year)), show.legend = FALSE) +\n        geom_node_point() + \n        labs(title = paste0('Layout: ', x))\n    \n    return(p)\n})\n\nwrap_plots(plots, nrow = 2)\n```\n\n::: {.cell-output-display}\n![](04_network_visualization_files/figure-html/unnamed-chunk-11-1.png){fig-align='center' width=672}\n:::\n:::\n\n\n#### Hive plots\n\nHive plots have become increasingly popular to visualize large networks,\nbecause they display nodes on radially distributed linear axes, each axis\nrepresenting a level of a node attribute. For example, using the `highschool`\ndata set, let's create a variable `friends` indicating whether each person\nhas few, medium, or many friends.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Add degree information to highschool network\nhs_graph <- as_tbl_graph(highschool) |>\n    mutate(degree = centrality_degree(mode = \"in\")) |>\n    mutate(\n        friends = case_when(\n            degree <5 ~ \"few\",\n            degree >=15 ~ \"many\",\n            TRUE ~ \"medium\"\n        )\n    )\n\nhs_graph\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tbl_graph: 70 nodes and 506 edges\n#\n# A directed multigraph with 1 component\n#\n# Node Data: 70 × 2 (active)\n   degree friends\n    <dbl> <chr>  \n 1      2 few    \n 2      0 few    \n 3      0 few    \n 4      4 few    \n 5      5 medium \n 6      2 few    \n 7      2 few    \n 8      3 few    \n 9      4 few    \n10      4 few    \n# ℹ 60 more rows\n#\n# Edge Data: 506 × 3\n   from    to  year\n  <int> <int> <dbl>\n1     1    13  1957\n2     1    14  1957\n3     1    20  1957\n# ℹ 503 more rows\n```\n\n\n:::\n:::\n\n\nNow, we can create a hive plot showing each level of the `friends` variable\n(few, many, and medium) as an axis, with nodes mapped to each axis sorted\nby their degrees.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Create a hive plot\nggraph(hs_graph, \"hive\", axis = friends, sort.by = degree) + \n    geom_edge_hive(aes(colour = factor(year))) + \n    geom_axis_hive(aes(colour = friends), linewidth = 2, label = FALSE) + \n    coord_fixed()\n```\n\n::: {.cell-output-display}\n![](04_network_visualization_files/figure-html/unnamed-chunk-13-1.png){fig-align='center' width=672}\n:::\n:::\n\n\n#### Focal layouts\n\nFocal layouts are used to display all nodes relative to a central node (or\ngroup of nodes). The focal nodes can be, for example, nodes with high degree,\nor a node you want to highlight.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggraph(highschool, \"focus\", focus = node_is_center()) + \n    ggforce::geom_circle(\n        data = data.frame(r = 1:5), \n        aes(x0 = 0, y0 = 0, r = r), \n        colour = \"grey\"\n    ) + \n    geom_edge_link() + \n    geom_node_point() + \n    coord_fixed()\n```\n\n::: {.cell-output-display}\n![](04_network_visualization_files/figure-html/unnamed-chunk-14-1.png){fig-align='center' width=672}\n:::\n:::\n\n\n\n\n#### Hierarhical layouts\n\nHierarchical layouts are optimized to represent tree-like data, and `ggraph`\noffers several algorithms for such data, including 'ciclepack', 'treemap',\n'cactustree', 'tree', and 'dendrogram'. Here, we will focus on the most \ncommonly used ones using the `flare` data set.\n\nThe *'circlepack'* layout, like some other hierarchical layouts, can be used\nto display relations with enclosure and positions only, or with edges too.\nLet's demonstrate both ways.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Create `tbl_graph` object\ngraph <- tbl_graph(flare$vertices, flare$edges)\n\n# 1) Only enclosure and positions\np1 <- ggraph(graph, \"circlepack\", weight = size) + \n    geom_node_circle(aes(fill = depth), size = 0.25, n = 50) + \n    coord_fixed()\n\n# 2) Include edges\np2 <- ggraph(graph, \"circlepack\", weight = size) + \n    geom_edge_link() + \n    geom_node_point(aes(colour = depth)) +\n    coord_fixed()\n\np1 / p2\n```\n\n::: {.cell-output-display}\n![](04_network_visualization_files/figure-html/unnamed-chunk-15-1.png){fig-align='center' width=384}\n:::\n:::\n\n\nThe same data can also be represented as a tree using the *'tree'* layout.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggraph(graph, \"tree\") +\n    geom_edge_diagonal()\n```\n\n::: {.cell-output-display}\n![](04_network_visualization_files/figure-html/unnamed-chunk-16-1.png){fig-align='center' width=672}\n:::\n:::\n\n\nIn a tree representation, when node heights are important (with nested\nrelations, as in `hclust` objects), you would probably prefer to use \na *'dendrogram'* layout instead. To demonstrate this, let's create a dendrogram\nfrom the `iris` data set.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Create `hclust` object\ndendrogram <- hclust(dist(iris[, 1:4]))\n\nggraph(dendrogram, \"dendrogram\", height = height) +\n    geom_edge_elbow()\n```\n\n::: {.cell-output-display}\n![](04_network_visualization_files/figure-html/unnamed-chunk-17-1.png){fig-align='center' width=672}\n:::\n:::\n\n\n::: {.callout-tip}\n\n### Practice\n\nFor each of the data sets below, choose a suitable layout and plot them.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Data set 1\nds1 <- hclust(dist(USArrests), \"average\")\n\n# Data set 2\ndata(UKfaculty)\nds2 <- UKfaculty\n```\n:::\n\n\n::: {.callout appearance=\"minimal\" collapse=\"true\"}\n\n### Show me the solutions\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Data set 1\nggraph(ds1, \"dendrogram\", height = height) +\n    geom_edge_elbow()\n```\n\n::: {.cell-output-display}\n![](04_network_visualization_files/figure-html/unnamed-chunk-19-1.png){fig-align='center' width=672}\n:::\n\n```{.r .cell-code}\n# Data set 2\nggraph(ds2, \"stress\") +\n    geom_edge_link(alpha = 0.5, linewidth = 0.2)\n```\n\n::: {.cell-output-display}\n![](04_network_visualization_files/figure-html/unnamed-chunk-19-2.png){fig-align='center' width=672}\n:::\n:::\n\n\n:::\n:::\n\n### Nodes and edges\n\n__ggraph__ offers different node and edge options with the family of functions\n`geom_node_*()` and `geom_edge_*()`. Each function from each family is\nused for a specific kind of visualization, and below we're going to explore\nthe main ones.\n\n#### Node options: `geom_node_*()`\n\nThe most common node geom is `geom_node_point()`, which is used to create\nclassical node-edge diagrams. Let's take a look at an example below.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ng <- as_tbl_graph(highschool)\nggraph(g) +\n    geom_edge_link(color = \"gray70\") +\n    geom_node_point()\n```\n\n::: {.cell-output-display}\n![](04_network_visualization_files/figure-html/unnamed-chunk-20-1.png){fig-align='center' width=672}\n:::\n:::\n\n\nThe function `geom_node_voronoi()` display nodes as cells from a \nvoronoi tesselation, and it can be useful to show dominance of certain\nnode types.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ngraph <- create_notable('meredith') |> \n    mutate(group = sample(c('A', 'B'), n(), TRUE))\n\nggraph(graph) + \n    geom_node_voronoi(aes(fill = group), max.radius = 1) + \n    geom_node_point() + \n    geom_edge_link() + \n    coord_fixed()\n```\n\n::: {.cell-output-display}\n![](04_network_visualization_files/figure-html/unnamed-chunk-21-1.png){fig-align='center' width=672}\n:::\n:::\n\n\nThe function `geom_node_tile()` is typically used together \nwith `layout = 'treemap'` and `layout = 'partition'`. Let's see some examples.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Create `tbl_graph` from flare data set\ngraph <- tbl_graph(flare$vertices, flare$edges)\n\n# 1) Icicle diagram\np1 <- ggraph(graph, layout = 'partition') + \n    geom_node_tile(aes(y = y, fill = depth))\n\n# 2) Treemap\np2 <- ggraph(graph, layout = 'treemap', weight = size) + \n    geom_node_tile(aes(fill = depth))\n\np1 / p2\n```\n\n::: {.cell-output-display}\n![](04_network_visualization_files/figure-html/unnamed-chunk-22-1.png){fig-align='center' width=672}\n:::\n:::\n\n\nTo view all functions in the `geom_node_*()` family, you can \nexecute `??ggraph::geom_node_`.\n\n#### Edge options: `geom_edge_*()`\n\nAs we've seen before, the most common edge geom is `geom_edge_link()`,\nwhich simply draws a line between two nodes.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ng <- as_tbl_graph(highschool)\n\nggraph(g) +\n    geom_edge_link(aes(color = factor(year)))\n```\n\n::: {.cell-output-display}\n![](04_network_visualization_files/figure-html/unnamed-chunk-23-1.png){fig-align='center' width=672}\n:::\n:::\n\n\nIn case there are multiple edges between the same nodes, a better way of\nrepresenting them would be using the functions `geom_edge_fan()` and\n`geom_edge_parallel()`, as demonstrated below.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# 1) geom_edge_fan() - multi-edges as arcs with different curvature\np1 <- ggraph(g) +\n    geom_edge_fan(aes(color = factor(year)))\n\n# 2) geom_edge_parallel() - multi-edges as parallel lines\np2 <- ggraph(g) +\n    geom_edge_parallel(aes(color = factor(year)))\n\np1 / p2\n```\n\n::: {.cell-output-display}\n![](04_network_visualization_files/figure-html/unnamed-chunk-24-1.png){fig-align='center' width=480}\n:::\n:::\n\n\nIn some cases, arcs are a better way of representing edges, either in a linear\nor circular representation. Arcs can be created with `geom_edge_arc()`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# 1) geom_edge_arc(), linear\np1 <- ggraph(g, layout = \"linear\") +\n    geom_edge_arc(aes(color = factor(year))) +\n    coord_fixed()\n\n# 2) geom_edge_arc(), circular\np2 <- ggraph(g, layout = \"linear\", circular = TRUE) +\n    geom_edge_arc(aes(color = factor(year))) +\n    coord_fixed()\n\np1 / p2\n```\n\n::: {.cell-output-display}\n![](04_network_visualization_files/figure-html/unnamed-chunk-25-1.png){fig-align='center' width=480}\n:::\n:::\n\n\nAnother technique for drawing edges is **bundling**, which consists in\nbundling edges that flow in the same direction to avoid clutter. Many bundling\nalgorithms exist, but __ggraph__ offers 3 algorithms: force-directed,\nedge path, and minimal, available in geoms `geom_edge_bundle_force()`,\n`geom_edge_bundle_path()`, and `geom_edge_bundle_minimal()`, respectively.\nLet's demonstrate each of them.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Bundling with force-directed algorithm\np1 <- ggraph(g) +\n    geom_edge_bundle_force()\n\n# Bundling with edge path algorithm\np2 <- ggraph(g) +\n    geom_edge_bundle_path()\n\n# Bundling with minimal algorithm\np3 <- ggraph(g) +\n    geom_edge_bundle_minimal()\n\np1 / p2 / p3\n```\n\n::: {.cell-output-display}\n![](04_network_visualization_files/figure-html/unnamed-chunk-26-1.png){fig-align='center' width=480}\n:::\n:::\n\n\nTo visualize hierarchical data as a dendrogram, you can use `geom_edge_elbow()`\nor its smoother alternatives `geom_edge_diagonal()` and `geom_edge_bend()`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nh <- hclust(dist(iris[, 1:4]))\n\n# Dendrogram, elbow\np1 <- ggraph(h, layout = \"dendrogram\", height = height) +\n    geom_edge_elbow()\n\n# Dendrogram, diagonal\np2 <- ggraph(h, layout = \"dendrogram\", height = height) +\n    geom_edge_diagonal()\n\n# Dendrogram, bend\np3 <- ggraph(h, layout = \"dendrogram\", height = height) +\n    geom_edge_bend()\n\np1 + p2 + p3\n```\n\n::: {.cell-output-display}\n![](04_network_visualization_files/figure-html/unnamed-chunk-27-1.png){fig-align='center' width=768}\n:::\n:::\n\n\nImportantly, many edge geoms (including `geom_edge_elbow()`) can take a\n*strength* argument (from 0 to 1; default = 1) that indicates how much \nthe line deviates from a straight line. This way, you can plot a dendrogram\nwith `geom_edge_elbow()` that looks similar to one created \nwith `geom_edge_diagonal()`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggraph(h, layout = \"dendrogram\", height = height) +\n    geom_edge_elbow(strength = 0.5)\n```\n\n::: {.cell-output-display}\n![](04_network_visualization_files/figure-html/unnamed-chunk-28-1.png){fig-align='center' width=672}\n:::\n:::\n\n\nFinally, you can also decorate your edges with arrows and labels. To add\narrows, you will use the `arrow()` function in the *arrow* argument of\nthe edge geom. It's also important to specify a cap in argument *end_cap*\nso that the arrows have some distance from terminal nodes. Here is an\nexample:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Create 'bull' graph with {igraph} and add edge attributes\nbull <- make_graph(\"Bull\")\nE(bull)$type <- sample(c(\"friend\", \"foe\"), ecount(bull), TRUE)\ngbull <- as_tbl_graph(bull)\n\n# Plot graph with edges\nggraph(gbull, layout = 'graphopt') + \n    geom_edge_link(\n        arrow = arrow(length = unit(4, 'mm')), \n        end_cap = circle(3, 'mm')\n    ) + \n    geom_node_point(size = 5)\n```\n\n::: {.cell-output-display}\n![](04_network_visualization_files/figure-html/unnamed-chunk-29-1.png){fig-align='center' width=672}\n:::\n:::\n\n\nTo include edge labels in this same graph, you'd do:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggraph(gbull, layout = 'graphopt') + \n    geom_edge_link(\n        aes(label = type),\n        angle_calc = \"along\",\n        label_dodge = unit(2.5, \"mm\"),\n        arrow = arrow(length = unit(4, 'mm')), \n        end_cap = circle(3, 'mm')\n    ) + \n    geom_node_point(size = 5)\n```\n\n::: {.cell-output-display}\n![](04_network_visualization_files/figure-html/unnamed-chunk-30-1.png){fig-align='center' width=672}\n:::\n:::\n\n\n::: {.callout-tip}\n\n### Practice\n\nIn the plot above, with edges having labels and arrows, what happens if\nyou remove the arguments `angle_calc = \"along\"` and \n`label_dodge = unit(2.5, \"mm\")`? Based on what you observe, what do\nthese arguments control?\n\n::: {.callout appearance=\"minimal\" collapse=\"true\"}\n\n### Show me the solutions\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Removing `label_dodge` -> labels will be placed on top of the lines\nggraph(gbull, layout = 'graphopt') + \n    geom_edge_link(\n        aes(label = type),\n        angle_calc = \"along\",\n        arrow = arrow(length = unit(4, 'mm')), \n        end_cap = circle(3, 'mm')\n    ) + \n    geom_node_point(size = 5)\n```\n\n::: {.cell-output-display}\n![](04_network_visualization_files/figure-html/unnamed-chunk-31-1.png){fig-align='center' width=672}\n:::\n\n```{.r .cell-code}\n# Removing `angle_calc` -> labels will all have the same rotation\nggraph(gbull, layout = 'graphopt') + \n    geom_edge_link(\n        aes(label = type),\n        arrow = arrow(length = unit(4, 'mm')), \n        end_cap = circle(3, 'mm')\n    ) + \n    geom_node_point(size = 5)\n```\n\n::: {.cell-output-display}\n![](04_network_visualization_files/figure-html/unnamed-chunk-31-2.png){fig-align='center' width=672}\n:::\n:::\n\n\n:::\n:::\n\n\n## Visualizing large networks\n\nIn real-world network data analyses, we often work with large networks.\nWhile visualizing very large networks is generally not recommended\n(because it's hard to extract meaningful information from such visualizations),\nsometimes they can be useful to explore group structure in graphs. In this \nfinal section, we will use the Game of Thrones network we explored\nin previous chapters to demonstrate best practices to get the most out of\nnetwork visualizations, especially for large networks. \n\nLet's start by loading the data set and creating a simple node-edge\ndiagram (or hairball) with default parameters.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Load data set\ngot <- readRDS(here(\"data\", \"got.rds\"))\n\n# Get `tbl_graph` and plot it\ng <- as_tbl_graph(got)\n\np1 <- ggraph(g) + \n    geom_edge_link() +\n    geom_node_point()\n\np1\n```\n\n::: {.cell-output-display}\n![](04_network_visualization_files/figure-html/unnamed-chunk-32-1.png){fig-align='center' width=672}\n:::\n:::\n\n\nThis is a relatively large network (N = 107 nodes), and a simple visualization\nwith default parameters does not work so well. We can hardly extract any useful\ninformation from it. The first and very important thing you'd want to change\nin this plot would be **node size** and **colors**. It is considered standard\npractice to color nodes based on their shared properties (such as communities\ninferred with community detection algorithms), and to give them variables\nsizes based on their degree. Let's do this.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Add `degree` and `cluster` node attributes\nV(got)$cluster <- cluster_louvain(got) |> membership() |> as.character()\nV(got)$degree <- degree(got)\n\ng <- as_tbl_graph(got)\n\np2 <- ggraph(g) + \n    geom_edge_link() +\n    geom_node_point(aes(size = degree, fill = cluster), shape = 21)\n\np2\n```\n\n::: {.cell-output-display}\n![](04_network_visualization_files/figure-html/unnamed-chunk-33-1.png){fig-align='center' width=672}\n:::\n:::\n\n\nThis looks much better, right? But we can still improve it further. We can see\nthat a part of the graph is densely connected, which makes it a bit cluttered.\nTo make it look better, we can reduce line widths, and add a bit of \ntransparency to the edges.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\np3 <- ggraph(g) + \n    geom_edge_link(linewidth = 0.2, alpha = 0.6) +\n    geom_node_point(aes(size = degree, fill = cluster), shape = 21)\n\np3\n```\n\n::: {.cell-output-display}\n![](04_network_visualization_files/figure-html/unnamed-chunk-34-1.png){fig-align='center' width=672}\n:::\n:::\n\n\nLastly, we can also use a better color palette.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\np4 <- ggraph(g) + \n    geom_edge_link(linewidth = 0.2, alpha = 0.6) +\n    geom_node_point(aes(size = degree, fill = cluster), shape = 21) +\n    scale_fill_brewer(palette = \"Set1\")\n\np4\n```\n\n::: {.cell-output-display}\n![](04_network_visualization_files/figure-html/unnamed-chunk-35-1.png){fig-align='center' width=672}\n:::\n:::\n\n\nBy simply changing the aesthetics of nodes and edges, this is how we made\nout plot look better:\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](04_network_visualization_files/figure-html/unnamed-chunk-36-1.png){fig-align='center' width=768}\n:::\n:::\n\n\nBesides changing node and edge aesthetics, playing with different layouts\nis also very important when visualizing large networks. The default layouts\nin __ggraph__ (*'stress'* for most networks, and *'sparse_stress'* for very\nlarge networks) are excellent layouts that generally work well, but you\nmight want to test other approaches for large networks.\n\nA common approach consists in using focal layouts to emphasize certain nodes.\nThis can be done using `layout = \"focus\"` (to focus on a central node) or\n`layout = \"centrality\"` (similar to 'focus', but using a centrality measure).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# 'focus' layout\np1 <- ggraph(g, layout = \"focus\", focus = node_is_center()) + \n    geom_edge_link(linewidth = 0.2, alpha = 0.6) +\n    geom_node_point(aes(size = degree, fill = cluster), shape = 21) +\n    scale_fill_brewer(palette = \"Set1\") + \n    coord_fixed() +\n    theme(legend.position = \"none\")\n\n# 'centrality' layout (degree as centrality measure)\np2 <- ggraph(g, layout = \"centrality\", centrality = centrality_degree()) + \n    geom_edge_link(linewidth = 0.2, alpha = 0.6) +\n    geom_node_point(aes(size = degree, fill = cluster), shape = 21) +\n    scale_fill_brewer(palette = \"Set1\") + \n    coord_fixed() +\n    theme(legend.position = \"none\")\n\np1 + p2\n```\n\n::: {.cell-output-display}\n![](04_network_visualization_files/figure-html/unnamed-chunk-37-1.png){fig-align='center' width=672}\n:::\n:::\n\n\nA big advantage of these layouts, especially the *'centrality'* layout, is \nthat it's easier to see node labels, so we can quickly see which nodes are the\nmost important ones in the network. We can add node labels with `geom_node_text`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Add text to label nodes\np2 + geom_node_text(aes(label = name, size = degree), repel = TRUE)\n```\n\n::: {.cell-output-display}\n![](04_network_visualization_files/figure-html/unnamed-chunk-38-1.png){fig-align='center' width=672}\n:::\n:::\n\n\nFinally, the *'backbone'* layout can help emphasize hidden group structures\nin a graph, and its popularity has increased a lot, especially when\nvisualizing large graphs.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggraph(g, layout = \"backbone\", keep = 0.4) +\n    geom_edge_link(linewidth = 0.2, alpha = 0.6) +\n    geom_node_point(aes(size = degree, fill = cluster), shape = 21) +\n    scale_fill_brewer(palette = \"Set1\")\n```\n\n::: {.cell-output-display}\n![](04_network_visualization_files/figure-html/unnamed-chunk-39-1.png){fig-align='center' width=672}\n:::\n:::\n\n\nAs stated before, it is generally recommended to test multiple layout \nalgorithms, as each of them is optimized for a specific purpose.\n\n\n::: {.callout-tip}\n\n### Challenge\n\nThe `yeast` network is a very large network containing 2617 nodes. Use\nthe techniques you learned to visualize this network in an efficient way.\nTest at least two layouts.\n\nYou can load the data set using the code below.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndata(yeast)\n```\n:::\n\n\n*Hint:* this network contains a node attribute named `Class` that could\nbe used to group nodes.\n\n::: {.callout appearance=\"minimal\" collapse=\"true\"}\n\n### Show me the solutions\n\n**Note:** there is no single *right* solution for this challenge, but below\nis a possible approach.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Decompose graph and get giant component\ng <- decompose(yeast)[[1]]\n\n# Add `degree` and `cluster` node attributes\nV(g)$degree <- degree(g)\n\n# 'backbone' layout\nggraph(g, layout = \"backbone\", keep = 0.4) +\n    geom_edge_link(linewidth = 0.1, alpha = 0.6) +\n    geom_node_point(aes(size = degree, fill = Class), shape = 21) +\n    theme(legend.position = \"none\")\n```\n\n::: {.cell-output-display}\n![](04_network_visualization_files/figure-html/unnamed-chunk-41-1.png){fig-align='center' width=672}\n:::\n\n```{.r .cell-code}\n# 'sparse_stress' layout\nggraph(g) +\n    geom_edge_link(linewidth = 0.1, alpha = 0.6) +\n    geom_node_point(aes(size = degree, fill = Class), shape = 21) +\n    theme(legend.position = \"none\")\n```\n\n::: {.cell-output-display}\n![](04_network_visualization_files/figure-html/unnamed-chunk-41-2.png){fig-align='center' width=672}\n:::\n:::\n\n\n:::\n:::\n\n\n## Session information {.unnumbered}\n\nThis chapter was created under the following conditions:\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output .cell-output-stdout}\n\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.2 (2023-10-31)\n os       Ubuntu 22.04.3 LTS\n system   x86_64, linux-gnu\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       Europe/Brussels\n date     2024-04-19\n pandoc   3.1.1 @ /usr/lib/rstudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package      * version date (UTC) lib source\n BiocManager    1.30.22 2023-08-08 [1] CRAN (R 4.3.2)\n BiocStyle      2.30.0  2023-10-24 [1] Bioconductor\n cachem         1.0.8   2023-05-01 [1] CRAN (R 4.3.2)\n cli            3.6.2   2023-12-11 [1] CRAN (R 4.3.2)\n colorspace     2.1-0   2023-01-23 [1] CRAN (R 4.3.2)\n deldir         2.0-4   2024-02-28 [1] CRAN (R 4.3.2)\n digest         0.6.34  2024-01-11 [1] CRAN (R 4.3.2)\n dplyr        * 1.1.4   2023-11-17 [1] CRAN (R 4.3.2)\n evaluate       0.23    2023-11-01 [1] CRAN (R 4.3.2)\n fansi          1.0.6   2023-12-08 [1] CRAN (R 4.3.2)\n farver         2.1.1   2022-07-06 [1] CRAN (R 4.3.2)\n fastmap        1.1.1   2023-02-24 [1] CRAN (R 4.3.2)\n forcats      * 1.0.0   2023-01-29 [1] CRAN (R 4.3.2)\n generics       0.1.3   2022-07-05 [1] CRAN (R 4.3.2)\n ggforce        0.4.1   2022-10-04 [1] CRAN (R 4.3.2)\n ggplot2      * 3.5.0   2024-02-23 [1] CRAN (R 4.3.2)\n ggraph       * 2.2.1   2024-03-07 [1] CRAN (R 4.3.2)\n ggrepel        0.9.5   2024-01-10 [1] CRAN (R 4.3.2)\n glue           1.7.0   2024-01-09 [1] CRAN (R 4.3.2)\n graphlayouts   1.1.0   2024-01-19 [1] CRAN (R 4.3.2)\n gridExtra      2.3     2017-09-09 [1] CRAN (R 4.3.2)\n gtable         0.3.4   2023-08-21 [1] CRAN (R 4.3.2)\n here         * 1.0.1   2020-12-13 [1] CRAN (R 4.3.2)\n hms            1.1.3   2023-03-21 [1] CRAN (R 4.3.2)\n htmltools      0.5.7   2023-11-03 [1] CRAN (R 4.3.2)\n htmlwidgets    1.6.4   2023-12-06 [1] CRAN (R 4.3.2)\n igraph       * 2.0.1.1 2024-01-30 [1] CRAN (R 4.3.2)\n igraphdata   * 1.0.1   2015-07-13 [1] CRAN (R 4.3.2)\n jsonlite       1.8.8   2023-12-04 [1] CRAN (R 4.3.2)\n knitr          1.45    2023-10-30 [1] CRAN (R 4.3.2)\n labeling       0.4.3   2023-08-29 [1] CRAN (R 4.3.2)\n lattice        0.22-5  2023-10-24 [4] CRAN (R 4.3.1)\n lifecycle      1.0.4   2023-11-07 [1] CRAN (R 4.3.2)\n lubridate    * 1.9.3   2023-09-27 [1] CRAN (R 4.3.2)\n magrittr       2.0.3   2022-03-30 [1] CRAN (R 4.3.2)\n MASS           7.3-60  2023-05-04 [4] CRAN (R 4.3.1)\n Matrix         1.6-3   2023-11-14 [4] CRAN (R 4.3.2)\n memoise        2.0.1   2021-11-26 [1] CRAN (R 4.3.2)\n munsell        0.5.0   2018-06-12 [1] CRAN (R 4.3.2)\n oaqc           1.0     2017-11-14 [1] CRAN (R 4.3.2)\n patchwork    * 1.2.0   2024-01-08 [1] CRAN (R 4.3.2)\n pillar         1.9.0   2023-03-22 [1] CRAN (R 4.3.2)\n pkgconfig      2.0.3   2019-09-22 [1] CRAN (R 4.3.2)\n polyclip       1.10-6  2023-09-27 [1] CRAN (R 4.3.2)\n purrr        * 1.0.2   2023-08-10 [1] CRAN (R 4.3.2)\n R6             2.5.1   2021-08-19 [1] CRAN (R 4.3.2)\n RColorBrewer   1.1-3   2022-04-03 [1] CRAN (R 4.3.2)\n Rcpp           1.0.12  2024-01-09 [1] CRAN (R 4.3.2)\n readr        * 2.1.5   2024-01-10 [1] CRAN (R 4.3.2)\n rlang          1.1.3   2024-01-10 [1] CRAN (R 4.3.2)\n rmarkdown      2.25    2023-09-18 [1] CRAN (R 4.3.2)\n rprojroot      2.0.4   2023-11-05 [1] CRAN (R 4.3.2)\n rstudioapi     0.15.0  2023-07-07 [1] CRAN (R 4.3.2)\n scales         1.3.0   2023-11-28 [1] CRAN (R 4.3.2)\n sessioninfo    1.2.2   2021-12-06 [1] CRAN (R 4.3.2)\n stringi        1.8.3   2023-12-11 [1] CRAN (R 4.3.2)\n stringr      * 1.5.1   2023-11-14 [1] CRAN (R 4.3.2)\n tibble       * 3.2.1   2023-03-20 [1] CRAN (R 4.3.2)\n tidygraph    * 1.3.1   2024-01-30 [1] CRAN (R 4.3.2)\n tidyr        * 1.3.1   2024-01-24 [1] CRAN (R 4.3.2)\n tidyselect     1.2.0   2022-10-10 [1] CRAN (R 4.3.2)\n tidyverse    * 2.0.0   2023-02-22 [1] CRAN (R 4.3.2)\n timechange     0.3.0   2024-01-18 [1] CRAN (R 4.3.2)\n tweenr         2.0.2   2022-09-06 [1] CRAN (R 4.3.2)\n tzdb           0.4.0   2023-05-12 [1] CRAN (R 4.3.2)\n utf8           1.2.4   2023-10-22 [1] CRAN (R 4.3.2)\n vctrs          0.6.5   2023-12-01 [1] CRAN (R 4.3.2)\n viridis        0.6.5   2024-01-29 [1] CRAN (R 4.3.2)\n viridisLite    0.4.2   2023-05-02 [1] CRAN (R 4.3.2)\n withr          3.0.0   2024-01-16 [1] CRAN (R 4.3.2)\n xfun           0.42    2024-02-08 [1] CRAN (R 4.3.2)\n yaml           2.3.8   2023-12-11 [1] CRAN (R 4.3.2)\n\n [1] /home/faalm/R/x86_64-pc-linux-gnu-library/4.3\n [2] /usr/local/lib/R/site-library\n [3] /usr/lib/R/site-library\n [4] /usr/lib/R/library\n\n──────────────────────────────────────────────────────────────────────────────\n```\n\n\n:::\n:::\n",
    "supporting": [
      "04_network_visualization_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}