[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Network Analysis in R",
    "section": "",
    "text": "Preface\nThis book contains the materials for the course Network Analysis in R, which I offer in partnership with Physalia courses. This is a 4-day course, and each chapter of this book contains the materials for one day. In details:\n\nNetworks in data: an introduction to {igraph}\nNetwork statistics\nNetwork modeling\nNetwork visualization",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "chapters/00_setup.html",
    "href": "chapters/00_setup.html",
    "title": "Setup",
    "section": "",
    "text": "Software and required packages\nTo run the code in this book, you will need to install:\nAfter installing R and RStudio, you will need to install some required R packages. To do that, open RStudio and execute the code below in your console:\npkgs &lt;- c(\n    \"igraph\", \"igraphdata\", \"tidyverse\", \"here\", \"sand\",\n    \"tidygraph\", \"ggraph\", \"ggsci\", \"patchwork\", \"oaqc\"\n)\ninstall.packages(pkgs)",
    "crumbs": [
      "Setup"
    ]
  },
  {
    "objectID": "chapters/00_setup.html#software-and-required-packages",
    "href": "chapters/00_setup.html#software-and-required-packages",
    "title": "Setup",
    "section": "",
    "text": "R (&gt;=4.2.0): go to the CRAN website, choose your OS (Windows, Linux, or macOS), and follow the installation instructions.\nRStudio Desktop: go to the RStudio website and download the installer for your OS.",
    "crumbs": [
      "Setup"
    ]
  },
  {
    "objectID": "chapters/00_setup.html#course-materials",
    "href": "chapters/00_setup.html#course-materials",
    "title": "Setup",
    "section": "Course materials",
    "text": "Course materials\nThroughout the course, you will use some example data sets that I created specifically for this course. You will also need code handouts to use during the live coding sessions.\nTo get all the materials you will need to:\n\nNavigate to https://github.com/almeidasilvaf/NAR\nClone the repository by clicking Code &gt; Download ZIP\nExtract the .zip file\n(Optional) Move the folder with all course materials to a directory of your choice in your machine (you don’t want to leave it in Downloads/, right?)",
    "crumbs": [
      "Setup"
    ]
  },
  {
    "objectID": "chapters/01_networks_in_data.html",
    "href": "chapters/01_networks_in_data.html",
    "title": "1  Networks in data: an introduction to {igraph}",
    "section": "",
    "text": "1.1 Creating igraph objects",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Networks in data: an introduction to __{igraph}__</span>"
    ]
  },
  {
    "objectID": "chapters/01_networks_in_data.html#creating-igraph-objects",
    "href": "chapters/01_networks_in_data.html#creating-igraph-objects",
    "title": "1  Networks in data: an introduction to {igraph}",
    "section": "",
    "text": "1.1.1 Option 1: the make_* functions\nThe igraph package provides users with a set of functions starting with make_* that can be used to create graphs. The simplest one is make_empty_graph(), which creates an empty graph (no edges) with as many nodes as you wish. For example:\n\n# Creating an empty graph with 10 nodes\ng &lt;- make_empty_graph(10)\n\n# Showing the igraph object, and its nodes and edges\ng\n\nIGRAPH 5cb281c D--- 10 0 -- \n+ edges from 5cb281c:\n\nV(g)\n\n+ 10/10 vertices, from 5cb281c:\n [1]  1  2  3  4  5  6  7  8  9 10\n\nE(g)\n\n+ 0/0 edges from 5cb281c:\n\n# Quickly visualize the graph\nplot(g)\n\n\n\n\n\n\n\n\nThe exact opposite of make_empty_graph() is the function make_full_graph(), which creates a fully connected graph.\n\n# Create a fully connected graph\ng &lt;- make_full_graph(n = 10)\n\n# Show nodes and edges, and plot it\nV(g)\n\n+ 10/10 vertices, from a6620e7:\n [1]  1  2  3  4  5  6  7  8  9 10\n\nE(g)\n\n+ 45/45 edges from a6620e7:\n [1] 1-- 2 1-- 3 1-- 4 1-- 5 1-- 6 1-- 7 1-- 8 1-- 9 1--10 2-- 3 2-- 4 2-- 5\n[13] 2-- 6 2-- 7 2-- 8 2-- 9 2--10 3-- 4 3-- 5 3-- 6 3-- 7 3-- 8 3-- 9 3--10\n[25] 4-- 5 4-- 6 4-- 7 4-- 8 4-- 9 4--10 5-- 6 5-- 7 5-- 8 5-- 9 5--10 6-- 7\n[37] 6-- 8 6-- 9 6--10 7-- 8 7-- 9 7--10 8-- 9 8--10 9--10\n\nplot(g)\n\n\n\n\n\n\n\n\nTo create a custom graph from pre-defined edges, you’d use the function make_graph(), which is very flexible. For example, suppose you want to create a graph based on the following description:\n\n10 nodes;\n2 edges connecting nodes 1 and 2, and nodes 1 and 5.\n\nYou can do that with make_graph() as follows:\n\ng &lt;- make_graph(edges = c(1, 2, 1, 5), n = 10, directed = FALSE)\n\nplot(g)\n\n\n\n\n\n\n\n\nAlternatively, you can use igraph’s formula notation in make_graph():\n\ng2 &lt;- make_graph(~ 1--2, 1--5, 3, 4, 5, 6, 7, 8, 9, 10)\n\nplot(g2)\n\n\n\n\n\n\n\n\nBoth approaches above result in the same graph. This can be checked with:\n\nisomorphic(g, g2)\n\n[1] TRUE\n\n\n\n\n\n\n\n\nPractice\n\n\n\n\nCreate a graph with the following properties:\n\n\n4 nodes named A, B, C, and D\nEdges between node A and all other nodes\n\n\nRecreate the graphs below using the make_graph() function.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe function make_graph() can also create some notable graphs when users specify their names as input. Read the documentation of this function (accessible by running ?make_graph) and visualize at least 5 examples.\n\n\n\n\n\n\n\nShow me the solutions\n\n\n\n\n\n\n# Q1\ng1 &lt;- make_graph(edges = c(\"A\", \"B\", \"A\", \"C\", \"A\", \"D\"))\n\n# Q2\ng1 &lt;- make_graph(edges = c(1,2, 1,3, 1,4, 1,5, 1,6), n = 6, directed = FALSE)\ng2 &lt;- make_graph(~ A--B, B--C, C--D, D--E)\ng3 &lt;- make_graph(~A--B, B--C, C--A)\ng4 &lt;- make_graph(~A--B, B--C, B--D, C--E, C--F)\n\n# Q3\nsolids &lt;- list(\n  make_graph(\"Tetrahedron\"),\n  make_graph(\"Cubical\"),\n  make_graph(\"Octahedron\"),\n  make_graph(\"Dodecahedron\"),\n  make_graph(\"Icosahedron\")\n)\n\nplot(solids[[1]])\n\n\n\n\n\n\n\nplot(solids[[2]])\n\n\n\n\n\n\n\nplot(solids[[3]])\n\n\n\n\n\n\n\nplot(solids[[4]])\n\n\n\n\n\n\n\nplot(solids[[5]])\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n1.1.2 Option 2: from an adjacency matrix\nConstructing graphs manually using the make_graph() function can be useful for schematic examples or for very small graphs. However, real-world network analyses usually involve working with large graphs, with hundreds (or even thousands) of nodes. A very common way of representing networks with data consists in using adjacency matrices. An adjacency matrix \\(m_{ij}\\) contains nodes in rows and columns, and matrix elements indicate whether there is an edge between nodes i and j. Let’s simulate an adjacency matrix:\n\n# Simulate an adjacency matrix\nadjm &lt;- matrix(\n    sample(0:1, 100, replace = TRUE, prob = c(0.9, 0.1)), \n    ncol = 10,\n    dimnames = list(LETTERS[1:10], LETTERS[1:10])\n)\n\nadjm\n\n  A B C D E F G H I J\nA 0 0 0 0 0 0 0 1 1 0\nB 0 0 1 0 0 0 0 0 0 0\nC 0 0 0 0 1 0 0 0 0 1\nD 0 0 0 0 0 1 0 0 0 1\nE 0 0 0 0 0 1 1 1 0 0\nF 0 0 0 0 0 0 0 0 0 0\nG 0 0 0 0 1 1 0 0 0 0\nH 0 0 0 0 0 0 0 0 0 0\nI 0 0 0 0 0 0 0 0 0 0\nJ 0 0 0 0 0 0 0 0 0 0\n\n\nIn this example, we have a binary matrix, with 1 indicating that two nodes interact, and 0 indicating otherwise. We could also have numeric values (e.g., from 0 to 1) in matrix elements instead of 0s and 1s, which would then indicate the strength of the link between two nodes. You can create an igraph object from an adjacency matrix with the function graph_from_adjacency_matrix().\n\n# Create a graph from an adjacency matrix\ng &lt;- graph_from_adjacency_matrix(adjm)\n\ng\n\nIGRAPH 0acc06b DN-- 10 12 -- \n+ attr: name (v/c)\n+ edges from 0acc06b (vertex names):\n [1] A-&gt;H A-&gt;I B-&gt;C C-&gt;E C-&gt;J D-&gt;F D-&gt;J E-&gt;F E-&gt;G E-&gt;H G-&gt;E G-&gt;F\n\nplot(g)\n\n\n\n\n\n\n\n\n\n\n1.1.3 Option 3: from an edge list\nAnother very common way of representing networks in data consists in using edge lists, which are data frames containing the edges in columns 1 and 2. Any additional columns will be interpreted as (optional) edge attributes. Let’s simulate an edge list.\n\n# Simulate an edge list\nedgelist &lt;- data.frame(\n    from = c(\"A\", \"A\", \"B\"),\n    to = c(\"B\", \"C\", \"C\")\n)\n\nedgelist\n\n  from to\n1    A  B\n2    A  C\n3    B  C\n\n\nAs in an adjacency matrix, you could also add a third column indicating the strength of the edge. You can create an igraph object from an edge list with the functions graph_from_edgelist() or graph_from_data_frame().\n\n# Create a graph from an edge list\ng &lt;- graph_from_edgelist(as.matrix(edgelist))\ng2 &lt;- graph_from_data_frame(edgelist)\n\nidentical_graphs(g, g2)\n\n[1] TRUE\n\nplot(g)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Networks in data: an introduction to __{igraph}__</span>"
    ]
  },
  {
    "objectID": "chapters/01_networks_in_data.html#understanding-and-constructing-different-network-types",
    "href": "chapters/01_networks_in_data.html#understanding-and-constructing-different-network-types",
    "title": "1  Networks in data: an introduction to {igraph}",
    "section": "1.2 Understanding and constructing different network types",
    "text": "1.2 Understanding and constructing different network types\nGraphs can be classified into different types based on edge attributes named directionality and weight. These graph types are:\n\nDirected vs undirected: in directed graphs, edges have a direction (i.e., from a node to another), while in undirected graphs such directions do not exist.\nWeighted vs unweighted: in weighted graphs, edges have weights indicating the strength of association between two nodes, while in unweighted graphs edges are binary.\n\nTo demonstrate how to create these different graph types, consider the edge list below:\n\n# Create edge list with weights\nedges &lt;- data.frame(\n    from = c(\"A\", \"A\", \"B\", \"C\"),\n    to = c(\"B\", \"C\", \"C\", \"D\"),\n    weight = sample(seq(0, 1, by = 0.1), 4)\n)\n\nedges\n\n  from to weight\n1    A  B    0.8\n2    A  C    0.5\n3    B  C    0.7\n4    C  D    0.3\n\n\nYou can create four different graph types from this edge list by playing with arguments in graph_from_data_frame():\n\n# Graph 1: unweighted, undirected\ng1 &lt;- graph_from_data_frame(edges[, c(1,2)], directed = FALSE)\n\n# Graph 2: unweighted, directed\ng2 &lt;- graph_from_data_frame(edges[, c(1,2)], directed = TRUE)\n\n# Graph 3: weighted, undirected\ng3 &lt;- graph_from_data_frame(edges, directed = FALSE)\n\n# Graph 4: weighted, directed\ng4 &lt;- graph_from_data_frame(edges, directed = TRUE)\n\n# Show igraph objects\nlist(g1, g2, g3, g4)\n\n[[1]]\nIGRAPH 7ff90df UN-- 4 4 -- \n+ attr: name (v/c)\n+ edges from 7ff90df (vertex names):\n[1] A--B A--C B--C C--D\n\n[[2]]\nIGRAPH 8dbda16 DN-- 4 4 -- \n+ attr: name (v/c)\n+ edges from 8dbda16 (vertex names):\n[1] A-&gt;B A-&gt;C B-&gt;C C-&gt;D\n\n[[3]]\nIGRAPH 582f71d UNW- 4 4 -- \n+ attr: name (v/c), weight (e/n)\n+ edges from 582f71d (vertex names):\n[1] A--B A--C B--C C--D\n\n[[4]]\nIGRAPH 247f104 DNW- 4 4 -- \n+ attr: name (v/c), weight (e/n)\n+ edges from 247f104 (vertex names):\n[1] A-&gt;B A-&gt;C B-&gt;C C-&gt;D\n\n\nWhen the edge list includes a third column with a numeric variable, the function graph_from_data_frame() automatically adds it as an edge attribute named weight. You can add as many edge attributes as you wish.\nBesides adding edge attributes, you can also add node (or vertex) attributes. In the example below, we create a more complex graph, with multiple edge and node attributes.\n\n# Create edge list with two edge attributes\nedges &lt;- data.frame(\n    from = c(\"A\", \"A\", \"B\", \"C\"),\n    to = c(\"B\", \"C\", \"C\", \"D\"),\n    weight = sample(seq(-1, 1, by = 0.1), 4)\n)\nedges$weight_type &lt;- ifelse(edges$weight &gt; 0, \"positive\", \"negative\")\n\nedges\n\n  from to weight weight_type\n1    A  B    0.0    negative\n2    A  C    1.0    positive\n3    B  C   -0.2    negative\n4    C  D    0.5    positive\n\n# Create a data frame of node attributes\nnode_attrs &lt;- data.frame(\n    node = c(\"A\", \"B\", \"C\", \"D\"),\n    group = c(1, 1, 2, 2)\n)\n\nnode_attrs\n\n  node group\n1    A     1\n2    B     1\n3    C     2\n4    D     2\n\n# Create a graph with both edge and node attributes\ncg &lt;- graph_from_data_frame(edges, directed = FALSE, vertices = node_attrs)\n\ncg\n\nIGRAPH c1988bd UNW- 4 4 -- \n+ attr: name (v/c), group (v/n), weight (e/n), weight_type (e/c)\n+ edges from c1988bd (vertex names):\n[1] A--B A--C B--C C--D\n\n# Printing node and edge attributes\nvertex_attr_names(cg)\n\n[1] \"name\"  \"group\"\n\nedge_attr_names(cg)\n\n[1] \"weight\"      \"weight_type\"\n\n\n\n\n\n\n\n\nPractice\n\n\n\n\nThe code below creates a correlation matrix from the mtcars data set. Use this correlation matrix to create an undirected weighted graph.\n\n\ncormat &lt;- cor(t(mtcars[, c(1, 3:7)]))\n\n\nThe code below converts the correlation matrix created above to an edge list. Create the same graph you created before, but now from an edge list. Then, check if graphs are indeed the same.\n\nHint: use the simplify() function to remove loops (edges that connect a node to itself).\n\ncormat_edges &lt;- reshape2::melt(cormat)\n\n\nFrom the edge list created above, add an edge attribute named strength that contains the character strong for edges with weight &gt;=0.9, and moderate otherwise. Then, create a graph and inspect this attribute.\nFrom the edge list created in question 3, create a data frame of node attributes containing an attribute named brand containing the brands of each car.\n\n\n\n\n\n\n\nShow me the solutions\n\n\n\n\n\n\n# Q1\ng &lt;- graph_from_adjacency_matrix(\n    cormat, mode = \"undirected\", weighted = TRUE, diag = FALSE\n)\n\n# Q2\ng2 &lt;- graph_from_data_frame(cormat_edges, directed = FALSE)\nisomorphic(g, simplify(g2))\n\n[1] TRUE\n\n# Q3\ng3 &lt;- cormat_edges |&gt;\n    mutate(strength = ifelse(value &gt;= 0.9, \"strong\", \"moderate\")) |&gt;\n    graph_from_data_frame(directed = FALSE)\n\n# Q4\nbrands &lt;- data.frame(node = unique(c(cormat_edges$Var1, cormat_edges$Var2))) |&gt;\n    mutate(brand = gsub(\" .*\", \"\", node))\n\ng4 &lt;- graph_from_data_frame(cormat_edges, directed = FALSE, vertices = brands)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Networks in data: an introduction to __{igraph}__</span>"
    ]
  },
  {
    "objectID": "chapters/01_networks_in_data.html#manipulating-igraph-objects",
    "href": "chapters/01_networks_in_data.html#manipulating-igraph-objects",
    "title": "1  Networks in data: an introduction to {igraph}",
    "section": "1.3 Manipulating igraph objects",
    "text": "1.3 Manipulating igraph objects\nTo add or remove nodes from an igraph object, you can use the functions add_vertices() and delete_vertices() as demonstrated below:\n# Create empty graph with 4 nodes\ng &lt;- make_empty_graph(4)\nplot(g)\n# Add 3 nodes\ng &lt;- add_vertices(g, 3)\nplot(g)\n# Remove nodes 6 and 7\ng &lt;- delete_vertices(g, c(6, 7))\nplot(g)\n\n\n\n\n\n\n\n\n\n\n\n\n\nSimilarly, you can add edges to an igraph object with the function add_edges().\n# Create empty graph with 4 nodes\ng &lt;- make_empty_graph(4)\nplot(g)\n# Add edges 1--2, 1--3 and 1--4\ng &lt;- add_edges(g, edges = c(1,2, 1,3, 1,4))\nplot(g)\n\n\n\n\n\n\n\n\n\n\nTo remove edges, you will first need to get the IDs of the edges you want to remove. This can be done with the function get.edge_ids(). Once you have the IDs of the edges to be removed, you can use the function delete_edges() to do so.\n\n# Get IDs of edges 1--2 and 1--3\nids_remove &lt;- get.edge.ids(g, c(1,2, 1,3))\n\n# Remove edges indicated in `ids_remove`\ng &lt;- delete_edges(g, ids_remove)\n\nplot(g)\n\n\n\n\n\n\n\n\nBesides adding/removing nodes and edges, you can also add/remove node and edge attributes. These can be done in two ways: with the functions set_vertex_attr() and set_edge_attr(), or using the $ operator in the output of V() and E() the same way you do when adding a variable to a data frame. For example, consider the graph below.\n\n# Create graph using the 'Zachary' (karate club) data set\ng &lt;- make_graph(\"Zachary\")\n\nplot(g)\n\n\n\n\n\n\n\n\nYou can add node attributes using one of the following approaches:\n\n# Simulate a node attribute `sex` with 'male' and 'female'\nsex &lt;- sample(c(\"male\", \"female\"), vcount(g), replace = TRUE)\n\n# Approach 1: set_vertex_attr()\ng1 &lt;- set_vertex_attr(g, \"gender\", value = sex)\n\nvertex_attr_names(g1)\n\n[1] \"gender\"\n\nV(g1)$gender\n\n [1] \"male\"   \"female\" \"female\" \"male\"   \"male\"   \"male\"   \"female\" \"male\"  \n [9] \"male\"   \"female\" \"male\"   \"male\"   \"female\" \"male\"   \"male\"   \"male\"  \n[17] \"male\"   \"male\"   \"female\" \"female\" \"male\"   \"male\"   \"male\"   \"female\"\n[25] \"male\"   \"female\" \"male\"   \"male\"   \"male\"   \"female\" \"female\" \"female\"\n[33] \"female\" \"male\"  \n\n# Approach 2: $ operator\ng2 &lt;- g\nV(g2)$gender &lt;- sex\n\nvertex_attr_names(g2)\n\n[1] \"gender\"\n\nV(g2)$gender\n\n [1] \"male\"   \"female\" \"female\" \"male\"   \"male\"   \"male\"   \"female\" \"male\"  \n [9] \"male\"   \"female\" \"male\"   \"male\"   \"female\" \"male\"   \"male\"   \"male\"  \n[17] \"male\"   \"male\"   \"female\" \"female\" \"male\"   \"male\"   \"male\"   \"female\"\n[25] \"male\"   \"female\" \"male\"   \"male\"   \"male\"   \"female\" \"female\" \"female\"\n[33] \"female\" \"male\"  \n\n# Checking if graphs are the same\nidentical_graphs(g1, g2)\n\n[1] TRUE\n\n\nThe same can be done for edge attributes.\n\n# Simulate an edge attribute `weight`\nweight &lt;- runif(ecount(g), 0, 1)\n\n# Approach 1: set_edge_attr()\ng1 &lt;- set_edge_attr(g, \"weight\", value = weight)\n\nedge_attr_names(g1)\n\n[1] \"weight\"\n\nE(g1)$weight\n\n [1] 0.90738049 0.37635786 0.34531326 0.21946586 0.13228278 0.13507009\n [7] 0.08853259 0.78730386 0.35807888 0.29391158 0.40450132 0.13381784\n[13] 0.46851664 0.96685776 0.43449663 0.20073533 0.91053219 0.06783826\n[19] 0.82759449 0.23656741 0.27750932 0.67660508 0.71850210 0.59585793\n[25] 0.90803670 0.96113321 0.30684454 0.32653913 0.17554868 0.47100477\n[31] 0.16614016 0.01465749 0.57004785 0.01040247 0.05366550 0.93736147\n[37] 0.27528845 0.49616664 0.38447575 0.83071796 0.96821445 0.42522784\n[43] 0.61622431 0.43404264 0.50350546 0.70605198 0.84839995 0.81655145\n[49] 0.83680556 0.82331943 0.94625621 0.10089687 0.92175100 0.09025842\n[55] 0.01070081 0.31031531 0.77869046 0.74516384 0.07696548 0.52209787\n[61] 0.06152497 0.81003844 0.78088586 0.55043131 0.08312209 0.11898886\n[67] 0.07949653 0.58837430 0.88259873 0.95365913 0.85435595 0.32205234\n[73] 0.71748372 0.96839190 0.68511963 0.46812786 0.26695170 0.07534844\n\n# Approach 2: $ operator\ng2 &lt;- g\nE(g2)$weight &lt;- weight\n\nedge_attr_names(g2)\n\n[1] \"weight\"\n\nE(g2)$weight\n\n [1] 0.90738049 0.37635786 0.34531326 0.21946586 0.13228278 0.13507009\n [7] 0.08853259 0.78730386 0.35807888 0.29391158 0.40450132 0.13381784\n[13] 0.46851664 0.96685776 0.43449663 0.20073533 0.91053219 0.06783826\n[19] 0.82759449 0.23656741 0.27750932 0.67660508 0.71850210 0.59585793\n[25] 0.90803670 0.96113321 0.30684454 0.32653913 0.17554868 0.47100477\n[31] 0.16614016 0.01465749 0.57004785 0.01040247 0.05366550 0.93736147\n[37] 0.27528845 0.49616664 0.38447575 0.83071796 0.96821445 0.42522784\n[43] 0.61622431 0.43404264 0.50350546 0.70605198 0.84839995 0.81655145\n[49] 0.83680556 0.82331943 0.94625621 0.10089687 0.92175100 0.09025842\n[55] 0.01070081 0.31031531 0.77869046 0.74516384 0.07696548 0.52209787\n[61] 0.06152497 0.81003844 0.78088586 0.55043131 0.08312209 0.11898886\n[67] 0.07949653 0.58837430 0.88259873 0.95365913 0.85435595 0.32205234\n[73] 0.71748372 0.96839190 0.68511963 0.46812786 0.26695170 0.07534844\n\n# Checking if graphs are the same\nidentical_graphs(g1, g2)\n\n[1] TRUE\n\n\n\n\n\n\n\n\nPractice\n\n\n\n\nUse the code below to create an igraph object.\n\n\n# Create `igraph` object from mtcars data set\ngraph &lt;- cor(t(mtcars[, c(1, 3:7)])) |&gt; \n    graph_from_adjacency_matrix(\n        mode = \"undirected\", weighted = TRUE, diag = FALSE\n    )\n\nThen, add the following attributes:\n\nAn edge attribute named strength that contains the character strong for edges with weight &gt;=0.9, and moderate otherwise.\nA node attribute named brand containing the brands of each car.\n\nHint: this is the same exercise you did in a previous section, but now you’re adding attributes using the igraph object itself, not the graph’s edge list.\n\nUsing the graph created above, remove edges with attribute weight &lt;0.95.\n\nHint: you can use logical subsetting to extract edges that match the required condition.\n\n\n\n\n\n\nShow me the solutions\n\n\n\n\n\n\n# Q1\nE(graph)$strength &lt;- ifelse(E(graph)$weight &gt;= 0.9, \"strong\", \"moderate\")\nV(graph)$brand &lt;- gsub(\" .*\", \"\", V(graph)$name)\n\nE(graph)$strength\n\n  [1] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n  [7] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n [13] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n [19] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n [25] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n [31] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n [37] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n [43] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n [49] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n [55] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n [61] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n [67] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n [73] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n [79] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n [85] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n [91] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n [97] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[103] \"strong\"   \"strong\"   \"strong\"   \"moderate\" \"strong\"   \"strong\"  \n[109] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"moderate\"\n[115] \"strong\"   \"moderate\" \"moderate\" \"strong\"   \"strong\"   \"strong\"  \n[121] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[127] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[133] \"moderate\" \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[139] \"strong\"   \"strong\"   \"moderate\" \"strong\"   \"moderate\" \"moderate\"\n[145] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[151] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[157] \"strong\"   \"strong\"   \"moderate\" \"strong\"   \"strong\"   \"strong\"  \n[163] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"moderate\" \"strong\"  \n[169] \"moderate\" \"moderate\" \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[175] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[181] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[187] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[193] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[199] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[205] \"strong\"   \"strong\"   \"strong\"   \"moderate\" \"strong\"   \"strong\"  \n[211] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"moderate\"\n[217] \"strong\"   \"moderate\" \"moderate\" \"strong\"   \"strong\"   \"strong\"  \n[223] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[229] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[235] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[241] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[247] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[253] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[259] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[265] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[271] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[277] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[283] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[289] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[295] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[301] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[307] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[313] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[319] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[325] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[331] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[337] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[343] \"strong\"   \"strong\"   \"strong\"   \"moderate\" \"strong\"   \"moderate\"\n[349] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[355] \"strong\"   \"moderate\" \"strong\"   \"moderate\" \"moderate\" \"strong\"  \n[361] \"strong\"   \"strong\"   \"strong\"   \"moderate\" \"strong\"   \"strong\"  \n[367] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"moderate\"\n[373] \"strong\"   \"moderate\" \"moderate\" \"strong\"   \"strong\"   \"strong\"  \n[379] \"moderate\" \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[385] \"strong\"   \"strong\"   \"moderate\" \"strong\"   \"moderate\" \"strong\"  \n[391] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[397] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[403] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[409] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[415] \"strong\"   \"moderate\" \"moderate\" \"strong\"   \"strong\"   \"moderate\"\n[421] \"moderate\" \"strong\"   \"moderate\" \"strong\"   \"strong\"   \"strong\"  \n[427] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[433] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[439] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[445] \"strong\"   \"strong\"   \"moderate\" \"strong\"   \"moderate\" \"moderate\"\n[451] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"moderate\"\n[457] \"strong\"   \"moderate\" \"moderate\" \"strong\"   \"strong\"   \"strong\"  \n[463] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[469] \"strong\"   \"strong\"   \"moderate\" \"strong\"   \"moderate\" \"moderate\"\n[475] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[481] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[487] \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n[493] \"strong\"   \"strong\"   \"strong\"   \"strong\"  \n\nV(graph)$brand\n\n [1] \"Mazda\"    \"Mazda\"    \"Datsun\"   \"Hornet\"   \"Hornet\"   \"Valiant\" \n [7] \"Duster\"   \"Merc\"     \"Merc\"     \"Merc\"     \"Merc\"     \"Merc\"    \n[13] \"Merc\"     \"Merc\"     \"Cadillac\" \"Lincoln\"  \"Chrysler\" \"Fiat\"    \n[19] \"Honda\"    \"Toyota\"   \"Toyota\"   \"Dodge\"    \"AMC\"      \"Camaro\"  \n[25] \"Pontiac\"  \"Fiat\"     \"Porsche\"  \"Lotus\"    \"Ford\"     \"Ferrari\" \n[31] \"Maserati\" \"Volvo\"   \n\n# Q2\nedges_remove &lt;- E(graph)[E(graph)$weight &lt; 0.95]\nfgraph &lt;- delete_edges(graph, edges_remove)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Networks in data: an introduction to __{igraph}__</span>"
    ]
  },
  {
    "objectID": "chapters/01_networks_in_data.html#subsetting-nodes-and-edges",
    "href": "chapters/01_networks_in_data.html#subsetting-nodes-and-edges",
    "title": "1  Networks in data: an introduction to {igraph}",
    "section": "1.4 Subsetting nodes and edges",
    "text": "1.4 Subsetting nodes and edges\nTo subset particular nodes and edges from an igraph object, you can use subsetting (logical or index-based) based on the output of V() and E(), respectively. For instance, consider the graph below:\n\n# Create Scooby-Doo network\nedges &lt;- data.frame(\n    from = c(\"Fred\", \"Fred\", \"Fred\", \"Velma\", \"Daphne\", \"Shaggy\"),\n    to = c(\"Velma\", \"Daphne\", \"Shaggy\", \"Shaggy\", \"Shaggy\", \"Scooby\")\n)\n\ng &lt;- graph_from_data_frame(edges, directed = FALSE)\n\ng\n\nIGRAPH dc1e72d UN-- 5 6 -- \n+ attr: name (v/c)\n+ edges from dc1e72d (vertex names):\n[1] Fred  --Velma  Fred  --Daphne Fred  --Shaggy Velma --Shaggy Daphne--Shaggy\n[6] Shaggy--Scooby\n\nplot(g)\n\n\n\n\n\n\n\n\nTo demonstrate how to subset nodes, let’s subset only nodes ‘Shaggy’ and ‘Scooby’.\n\n# Subset nodes 'Scooby' and 'Shaggy'\nV(g)[\"Scooby\", \"Shaggy\"]\n\n+ 2/5 vertices, named, from dc1e72d:\n[1] Scooby Shaggy\n\n# Same, but using indices\nV(g)[c(4,5)]\n\n+ 2/5 vertices, named, from dc1e72d:\n[1] Shaggy Scooby\n\n# Same again, but using logical subsetting\nV(g)[startsWith(name, \"S\")]\n\n+ 2/5 vertices, named, from dc1e72d:\n[1] Shaggy Scooby\n\n\nIn the third example above, note how node attributes (name) can be directly used for subsetting inside the brackets of V().\nTo subset edges, you’d use the same approach, but now with the E() function. As an example, let’s subset all edges that include node ‘Shaggy’.\n\n# Subset edges including node 'Shaggy'\nE(g)[.from(\"Shaggy\")]\n\n+ 4/6 edges from dc1e72d (vertex names):\n[1] Fred  --Shaggy Velma --Shaggy Daphne--Shaggy Shaggy--Scooby\n\n# Same, but using indices\nE(g)[3:6]\n\n+ 4/6 edges from dc1e72d (vertex names):\n[1] Fred  --Shaggy Velma --Shaggy Daphne--Shaggy Shaggy--Scooby\n\n\n\n\n\n\n\n\nPractice\n\n\n\nUse the code below to load an igraph object containing character relationships in the TV show “Game of Thrones”.\n\n# Load Game of Thrones network\ngot &lt;- readRDS(here(\"data\", \"got.rds\"))\n\nThen, subset the edges that include the characters ‘Arya’, ‘Sansa’, ‘Jon’, ‘Robb’, ‘Bran’, and ‘Rickon’. Which of these characters has more connections?\n\n\n\n\n\n\nShow me the solutions\n\n\n\n\n\n\n# Q1\nstark_connections &lt;- list(\n    Arya = E(got)[.from(\"Arya\")],\n    Sansa = E(got)[.from(\"Sansa\")],\n    Jon = E(got)[.from(\"Jon\")],\n    Robb = E(got)[.from(\"Robb\")],\n    Bran = E(got)[.from(\"Bran\")],\n    Rickon = E(got)[.from(\"Rickon\")]\n)\n\nlengths(stark_connections)\n\n  Arya  Sansa    Jon   Robb   Bran Rickon \n    19     26     26     25     14      6",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Networks in data: an introduction to __{igraph}__</span>"
    ]
  },
  {
    "objectID": "chapters/01_networks_in_data.html#exporting-graphs",
    "href": "chapters/01_networks_in_data.html#exporting-graphs",
    "title": "1  Networks in data: an introduction to {igraph}",
    "section": "1.5 Exporting graphs",
    "text": "1.5 Exporting graphs\nSometimes, users want to export their igraph objects to a file so they can visualize them in a network visualization software. This can be done with the function write_graph(), which exports igraph objects to multiple formats specified in the argument format (see ?write_graph() for details).\nFor example, Cytoscape is a very popular graph visualization tool, and it can take graphs as edge lists. To export igraph objects to edge lists, you could use the following code:\n\n# Export graph in `g` to a file named 'edgelist.txt'\nwrite_graph(g, file = \"edgelist.txt\", format = \"edgelist\")",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Networks in data: an introduction to __{igraph}__</span>"
    ]
  },
  {
    "objectID": "chapters/01_networks_in_data.html#session-information",
    "href": "chapters/01_networks_in_data.html#session-information",
    "title": "1  Networks in data: an introduction to {igraph}",
    "section": "Session information",
    "text": "Session information\nThis chapter was created under the following conditions:\n\n\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.2 (2023-10-31)\n os       Ubuntu 22.04.3 LTS\n system   x86_64, linux-gnu\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       Europe/Brussels\n date     2024-04-19\n pandoc   3.1.1 @ /usr/lib/rstudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package     * version date (UTC) lib source\n cli           3.6.2   2023-12-11 [1] CRAN (R 4.3.2)\n colorspace    2.1-0   2023-01-23 [1] CRAN (R 4.3.2)\n digest        0.6.34  2024-01-11 [1] CRAN (R 4.3.2)\n dplyr       * 1.1.4   2023-11-17 [1] CRAN (R 4.3.2)\n evaluate      0.23    2023-11-01 [1] CRAN (R 4.3.2)\n fansi         1.0.6   2023-12-08 [1] CRAN (R 4.3.2)\n fastmap       1.1.1   2023-02-24 [1] CRAN (R 4.3.2)\n forcats     * 1.0.0   2023-01-29 [1] CRAN (R 4.3.2)\n generics      0.1.3   2022-07-05 [1] CRAN (R 4.3.2)\n ggplot2     * 3.5.0   2024-02-23 [1] CRAN (R 4.3.2)\n glue          1.7.0   2024-01-09 [1] CRAN (R 4.3.2)\n gtable        0.3.4   2023-08-21 [1] CRAN (R 4.3.2)\n here        * 1.0.1   2020-12-13 [1] CRAN (R 4.3.2)\n hms           1.1.3   2023-03-21 [1] CRAN (R 4.3.2)\n htmltools     0.5.7   2023-11-03 [1] CRAN (R 4.3.2)\n htmlwidgets   1.6.4   2023-12-06 [1] CRAN (R 4.3.2)\n igraph      * 2.0.1.1 2024-01-30 [1] CRAN (R 4.3.2)\n jsonlite      1.8.8   2023-12-04 [1] CRAN (R 4.3.2)\n knitr         1.45    2023-10-30 [1] CRAN (R 4.3.2)\n lifecycle     1.0.4   2023-11-07 [1] CRAN (R 4.3.2)\n lubridate   * 1.9.3   2023-09-27 [1] CRAN (R 4.3.2)\n magrittr      2.0.3   2022-03-30 [1] CRAN (R 4.3.2)\n munsell       0.5.0   2018-06-12 [1] CRAN (R 4.3.2)\n pillar        1.9.0   2023-03-22 [1] CRAN (R 4.3.2)\n pkgconfig     2.0.3   2019-09-22 [1] CRAN (R 4.3.2)\n plyr          1.8.9   2023-10-02 [1] CRAN (R 4.3.2)\n purrr       * 1.0.2   2023-08-10 [1] CRAN (R 4.3.2)\n R6            2.5.1   2021-08-19 [1] CRAN (R 4.3.2)\n Rcpp          1.0.12  2024-01-09 [1] CRAN (R 4.3.2)\n readr       * 2.1.5   2024-01-10 [1] CRAN (R 4.3.2)\n reshape2      1.4.4   2020-04-09 [1] CRAN (R 4.3.2)\n rlang         1.1.3   2024-01-10 [1] CRAN (R 4.3.2)\n rmarkdown     2.25    2023-09-18 [1] CRAN (R 4.3.2)\n rprojroot     2.0.4   2023-11-05 [1] CRAN (R 4.3.2)\n rstudioapi    0.15.0  2023-07-07 [1] CRAN (R 4.3.2)\n scales        1.3.0   2023-11-28 [1] CRAN (R 4.3.2)\n sessioninfo   1.2.2   2021-12-06 [1] CRAN (R 4.3.2)\n stringi       1.8.3   2023-12-11 [1] CRAN (R 4.3.2)\n stringr     * 1.5.1   2023-11-14 [1] CRAN (R 4.3.2)\n tibble      * 3.2.1   2023-03-20 [1] CRAN (R 4.3.2)\n tidyr       * 1.3.1   2024-01-24 [1] CRAN (R 4.3.2)\n tidyselect    1.2.0   2022-10-10 [1] CRAN (R 4.3.2)\n tidyverse   * 2.0.0   2023-02-22 [1] CRAN (R 4.3.2)\n timechange    0.3.0   2024-01-18 [1] CRAN (R 4.3.2)\n tzdb          0.4.0   2023-05-12 [1] CRAN (R 4.3.2)\n utf8          1.2.4   2023-10-22 [1] CRAN (R 4.3.2)\n vctrs         0.6.5   2023-12-01 [1] CRAN (R 4.3.2)\n withr         3.0.0   2024-01-16 [1] CRAN (R 4.3.2)\n xfun          0.42    2024-02-08 [1] CRAN (R 4.3.2)\n yaml          2.3.8   2023-12-11 [1] CRAN (R 4.3.2)\n\n [1] /home/faalm/R/x86_64-pc-linux-gnu-library/4.3\n [2] /usr/local/lib/R/site-library\n [3] /usr/lib/R/site-library\n [4] /usr/lib/R/library\n\n──────────────────────────────────────────────────────────────────────────────",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Networks in data: an introduction to __{igraph}__</span>"
    ]
  },
  {
    "objectID": "chapters/02_network_statistics.html",
    "href": "chapters/02_network_statistics.html",
    "title": "2  Network statistics",
    "section": "",
    "text": "2.1 Node-level statistics\nIn a graph, some nodes are thought to be more important than others. However, “important” is a quite subjective term, so we need formal ways of measuring how central a node is in a network. These metrics are often referred to as centrality measures. There are many of such metrics, but some of the most commonly used are:\nTo demonstrate how to calculate these node statistics, consider the following graph:\ng &lt;- make_graph(\"Krackhardt kite\")\nplot(g)\nLet’s calculate different centrality measures:\n# Degree\nc1 &lt;- degree(g)\n\n# Closeness\nc2 &lt;- closeness(g)\n\n# Betweenness\nc3 &lt;- betweenness(g)\n\n# Eigenvector centrality\nc4 &lt;- eigen_centrality(g)$vector\n\n# Harmonic centrality\nc5 &lt;- harmonic_centrality(g)\n\n# Show all measures\ncentrality_summary &lt;- data.frame(\n    node = as.character(V(g)),\n    degree = c1,\n    closeness = c2,\n    betweenness = c3,\n    eigenvector = c4,\n    harmonic = c5\n)\n\ncentrality_summary\n\n   node degree  closeness betweenness eigenvector harmonic\n1     1      4 0.05882353   0.8333333  0.73221232 6.083333\n2     2      4 0.05882353   0.8333333  0.73221232 6.083333\n3     3      3 0.05555556   0.0000000  0.59422577 5.583333\n4     4      6 0.06666667   3.6666667  1.00000000 7.083333\n5     5      3 0.05555556   0.0000000  0.59422577 5.583333\n6     6      5 0.07142857   8.3333333  0.82676381 6.833333\n7     7      5 0.07142857   8.3333333  0.82676381 6.833333\n8     8      3 0.06666667  14.0000000  0.40717690 6.000000\n9     9      2 0.04761905   8.0000000  0.09994054 4.666667\n10   10      1 0.03448276   0.0000000  0.02320742 3.416667\nNote how the “most important” node in the graph changes depending on the centrality measure used. This example nicely illustrates the importance of using different centrality measures to assess a node’s importance in a graph.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Network statistics</span>"
    ]
  },
  {
    "objectID": "chapters/02_network_statistics.html#node-level-statistics",
    "href": "chapters/02_network_statistics.html#node-level-statistics",
    "title": "2  Network statistics",
    "section": "",
    "text": "Degree: number of connections of a node N. In weighted graphs, this is usually measured as the sum of weights of the edges containing node N. In directed graphs, we often distinguish between in-degree (number of ingoing edges) and out-degree (number of outgoing edges).\nCloseness: the average length of the shortest path between a node N and all other nodes in the graph.\nBetweenness: the number of shortest paths going through a node, which quantifies the number of times a node acts as a bridge along the shortest path between two other nodes.\nEigenvector centrality: first eigenvector of the graph’s adjacency matrix.\nHarmonic centrality: the mean inverse distance of a node N to all other nodes.\n\n\n\n\n\n\n\n\n\n\n\n\nPractice\n\n\n\nUse the code below to load an igraph object containing character relationships in the TV show “Game of Thrones”. Then, answer the questions below using this graph.\n\n# Load Game of Thrones network\ngot &lt;- readRDS(here(\"data\", \"got.rds\"))\n\n\nCalculate the degree, closeness, betweenness, eigenvector, and harmonic centralities of all nodes in this network. Which character is the most central based on each of these measures?\nIn network science, people often want to find hubs, which are the most highly connected nodes in a graph. Here, we will define as hubs the top 10% most highly connected nodes. Based on this definition, identify hubs in the got network.\n\n\n\n\n\n\n\nShow me the solutions\n\n\n\n\n\n\n# Q1\ngot_centrality &lt;- data.frame(\n    degree = degree(got),\n    closeness = closeness(got),\n    betweenness = betweenness(got),\n    eigenvector = eigen_centrality(got)$vector,\n    harmonic = harmonic_centrality(got)\n)\n\napply(got_centrality, 2, which.max)\n\n     degree   closeness betweenness eigenvector    harmonic \n          7           7           6           7           7 \n\n# Q2\ndeg &lt;- sort(degree(got), decreasing = TRUE)\ndeg[seq_len(length(deg) * 0.1)]\n\n Tyrion     Jon   Sansa    Robb   Jaime   Tywin  Cersei    Arya  Robert Joffrey \n     36      26      26      25      24      22      20      19      18      18",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Network statistics</span>"
    ]
  },
  {
    "objectID": "chapters/02_network_statistics.html#edge-level-statistics",
    "href": "chapters/02_network_statistics.html#edge-level-statistics",
    "title": "2  Network statistics",
    "section": "2.2 Edge-level statistics",
    "text": "2.2 Edge-level statistics\nIn network science, researchers usually can answer their questions by exploring node statistics. However, some questions can only be answered by analyzing edge statistics. For example, one might be interested in knowing which connections are more important for the flow of information (in social networks) or a molecular signal (in molecular networks).\nThe most common edge-level statistic is the edge betweenness, which is an extension of node betweenness describing the number of shortest paths traversing an edge E. Let’s calculate edge betweenness for all egdes in the graph we created before.\n\n# Calculate edge betweenness\nedge_betweenness(g)\n\n [1]  2.666667  1.500000  1.833333  4.666667  1.833333  1.500000  4.666667\n [8]  3.000000  4.500000  3.000000  3.333333  3.333333  4.500000  2.666667\n[15] 10.500000 10.500000 16.000000  9.000000\n\n\nIf you want to extract edges that have the highest betweenness, you’d do the following:\n\n# Extract edges with the highest betweenness centrality\neb &lt;- edge_betweenness(g)\nas_edgelist(g)[which.max(eb), ]\n\n[1] 8 9\n\n\nWhile the betweenness centrality can be extended to edges, other node centrality measures do not. One way to circumvent this is to create a line graph of a graph G, and then calculate centrality measures for the nodes of the line graph. A line graph of G, G’ = (V’, E’), is obtained by changing the nodes of a graph to edges, and edges to nodes. You can do that with igraph using the function make_line_graph().\n\n# Obtaining the line graph G' of a graph G\nlg &lt;- make_line_graph(g)\nlg\n\nIGRAPH 3c8919f U--- 18 57 -- Line graph\n+ attr: name (g/c)\n+ edges from 3c8919f:\n [1]  1-- 2  1-- 3  2-- 3  1-- 4  2-- 4  3-- 4  3-- 5  1-- 5  1-- 6  5-- 6\n[11]  1-- 7  5-- 7  6-- 7  3-- 8  5-- 8  2-- 8  4-- 9  2-- 9  8-- 9  6--10\n[21]  3--10  5--10  8--10  4--11  9--11  3--11  5--11  8--11 10--11  7--12\n[31]  3--12  5--12  8--12 10--12 11--12  7--13 12--13  6--13 10--13  7--14\n[41] 12--14 13--14  4--14  9--14 11--14  4--15  9--15 11--15 14--15 15--16\n[51]  7--16 12--16 13--16 14--16 15--17 16--17 17--18\n\n\nOnce you have the line graph of a graph G, you can calculate node centrality measures as described in the previous section (e.g., degree, closeness, etc.). Since nodes and edges have been swapped, node statistics of a line graph actually describe edge statistics of the original graph.\n\n\n\n\n\n\nPractice\n\n\n\nUsing the Game of Thrones graph from the previous practice problems, answer the questions below:\n\nWhich edges have the highest betweenness?\nCreate the line graph of this graph and calculate the degree, betweenness, and closeness of the line graph. Are the nodes with the highest values for each of these measures the same?\n\n\n\n\n\n\n\nShow me the solutions\n\n\n\n\n\n\n# Q1\neb &lt;- edge_betweenness(got)\nas_edgelist(got)[which.max(eb), ]\n\n[1] \"Robert\"   \"Daenerys\"\n\n# Q2\nlgot &lt;- make_line_graph(got)\nmax_degree &lt;- which.max(degree(lgot))\nmax_closeness &lt;- which.max(closeness(lgot))\nmax_betweenness &lt;- which.max(betweenness(lgot))\n\nlist(max_degree, max_closeness, max_betweenness)\n\n[[1]]\n[1] 289\n\n[[2]]\n[1] 243\n\n[[3]]\n[1] 90",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Network statistics</span>"
    ]
  },
  {
    "objectID": "chapters/02_network_statistics.html#assessing-network-cohesion",
    "href": "chapters/02_network_statistics.html#assessing-network-cohesion",
    "title": "2  Network statistics",
    "section": "2.3 Assessing network cohesion",
    "text": "2.3 Assessing network cohesion\nNetwork cohesion refers to the extent to which subsets of nodes are cohesive with respect to the relation defining edges in the graph. In molecular biology, for example, assessing network cohesion can reveal what proteins seem to work closely together in a cell; in social networks, one can investigate whether friends of person A tend to be friends of person B as well. There are many ways of assessing network cohesion, and we will explore the most common ones in the sections below.\n\n2.3.1 Subgraphs and censuses\nA popular way of defining network cohesion consists in analyzing frequencies of particular types of subgraphs. One of the most remarkable subgraphs is the clique, which are complete subgraphs (all nodes are connected by edges). Using the karate club network, let’s count the frequency of cliques of each size.\nCliques and maximal cliques\n\n# Create karate club graph\ng &lt;- make_graph(\"Zachary\")\n\n# Count frequency of cliques of each size\ntable(lengths(cliques(g)))\n\n\n 1  2  3  4  5 \n34 78 45 11  2 \n\n\nCliques of size 1 and 2 indicate nodes and edges, respectively, so they are are usually ignored when assessing network cohesion. Ignoring those, the table above shows that most of the cliques (N = 45) are triangles (size three), and the maximum clique size is 5.\nHowever, note that larger cliques can include smaller cliques, leading to some sort of redundancy. Because of that, it is often interesting to identify maximal cliques, which are defined as cliques that are not a subset of a larger clique. Let’s now count the frequency of maximal cliques.\n\n# Count the frequency of maximal cliques of each size\ntable(lengths(max_cliques(g)))\n\n\n 2  3  4  5 \n11 21  2  2 \n\n\nBesides cliques, other important types of subgraphs include dyads (pairs of nodes) and triads (triples of nodes), especially in directed graphs. In directed graphs, dyads can take on three possible states: null (no directed edge), assymetric (one directed edge), or mutual (two directed edges). Likewise, triads can take on 16 possible states.\nTo perform a census of the possible states of dyads and triads, you can use the functions dyad_census() and triad_census(), respectively. Let’s demonstrate it with the enron email network (emails generated by 500k employees of the Enron Corporation).\n\n# Load data set\ndata(enron)\n\n# Get dyad census (frequency of dyad states)\ndyad_census(enron)\n\n$mut\n[1] 913\n\n$asym\n[1] 1184\n\n$null\n[1] 14739\n\n\nIn this data set, we can see that, among non-null states, most dyads are assymetric.\nFinally, motifs are another commonly studied type of subgraph, especially in biological networks, and they are defined as small connected subgraphs that appear more often than the expected by chance. Below is an example of how to count motifs of size 3.\n\n# Get frequecy of motifs of size 3\nmotifs(g, size = 3)\n\n[1]  NA  NA 393  45\n\n\nThe order of the motifs is defined by their isomorphism class (see ?isomophism_class for details). Note that unconnected subgraphs are not considered to be motifs, so their frequencies will be result in NA.\n\n\n2.3.2 Relative frequency-based measures\nA common measure of network cohesion is the density of a graph, which describes the frequency of existing edges relative to the potential number of edges. This is a number that ranges between 0 and 1, and it can be estimated with the function edge_density(). Let’s demonstrate it by calculating the density of the entire graph for the karate club network, and for a subgraph containing only one of the instructors and its first-order neighbors\n\n# Calculate density of the entire graph\nedge_density(g)\n\n[1] 0.1390374\n\n# Calculate density of subgraph containing instructor (node 24) and neighbors\nsg &lt;- induced_subgraph(g, neighborhood(g, 1, 34)[[1]])\nedge_density(sg)\n\n[1] 0.2091503\n\n\nA somewhat similar measure is the clustering coefficient, which describes the number of connected triples that close to form triangles. This measure is also referred to as transitivity, which is why the igraph function to calculate it is called transitivity(). To calculate the clustering coefficient of the entire graph, you’d do as follows:\n\n# Calculate clustering coefficient of the graph\ntransitivity(g)\n\n[1] 0.2556818\n\n\nFinally, another measure that only applies to directed graphs is the reciprocity of a graph, which defines the number of dyads with reciprocated (i.e., mutual) directed egdes divided by the number of dyads with a single, unreciprocated edge. Let’s calculate the reciprocity of the enron network.\n\n# Calculate reciprocity of the `enron` network\nreciprocity(g)\n\n[1] 1\n\n\n\n\n2.3.3 Connectivity and cuts\nResearchers usually want to find out whether a graph separates into distinct subgraphs. In this context, a graph is said to be connected if every node is reachable from every other. To find out if a graph is connected, you can use the function is_connected(). Let’s demonstrate it in a network of protein-protein interactions in yeast (N = 2617 nodes).\n\n# Load yeast protein-protein interaction network\ndata(yeast)\n\n# Check if the network is connected\nis_connected(yeast)\n\n[1] FALSE\n\n\nThe fact that the network is not connected means that this large graph is broken into components. In such graphs, it often happens that one of these components is much larger than all the others, and this is called the giant component. To investigate if the yeast network contains a giant component, let’s decompose this graph into different components and count the number of nodes per component.\n\n# Decompose the graph and count number of nodes in each component\ncomps &lt;- decompose(yeast)\ntable(lengths(comps))\n\n\n   2    3    4    5    6    7 2375 \n  63   13    5    6    1    3    1 \n\n\nWe can see that there’s a single component with 2735 nodes (~90% of the total number of nodes), while other components have very few nodes. When this is the case, it is common practice to restrict further analyses to the giant component only, as the other smaller components are not very informative. Let’s extract the giant component.\n\n# Extract giant component\nyeast_gc &lt;- decompose(yeast)[[1]]\n\nGiant components usually display a remarkable characteristic termed small world property, which means that the average shortest-path distance is small, but clustering coefficient is high. Let’s check if this is the case here:\n\n# Get average path length and diameter\nmean_distance(yeast_gc)\n\n[1] 5.09597\n\ndiameter(yeast_gc)\n\n[1] 15\n\n# Get clustering coefficient\ntransitivity(yeast_gc)\n\n[1] 0.4686663\n\n\nIndeed, this giant component has a small average shortest-path distance, and relatively high clustering coefficient.\nIn a graph, there are usually some nodes that, if removed, can disconnect the graph. These are called articulation points or cut nodes, and they typically indicate parts of a network that are vulnerable to attacks. You can identify them with the function articulation_points() as below:\n\n# Get articulation points\nap &lt;- articulation_points(yeast_gc)\nlength(ap)\n\n[1] 350\n\n\nIn the giant component of the yeast network, 350 nodes are articulation points.\n\n\n\n\n\n\nPractice\n\n\n\nUsing the Game of Thrones graph from the previous practice problems, answer the questions below.\n\nHow many cliques of each size are there? What is the size of the largest clique?\nHow many maximal cliques of each size are there? What is the size of the largest maximal clique?\nWhat is the network’s density and clustering coefficient?\nIf this network connected?\nWhat is the network’s average shortest-path distance and diameter?\nHow many articulation points are there? What percentage of the total number of nodes does that represent?\n\n\n\n\n\n\n\nShow me the solutions\n\n\n\n\n\n\n# Q1\ngcl &lt;- cliques(got)\ntable(lengths(gcl))\n\n\n  1   2   3   4   5   6   7 \n107 352 469 330 124  22   1 \n\n# Q2\nmgcl &lt;- max_cliques(got)\ntable(lengths(mgcl))\n\n\n 2  3  4  5  6  7 \n22 24 44 30 15  1 \n\n# Q3\nedge_density(got)\n\n[1] 0.06207018\n\ntransitivity(got)\n\n[1] 0.3286615\n\n# Q4\nis_connected(got)\n\n[1] TRUE\n\n# Q5\nmean_distance(got)\n\n[1] 22.06366\n\ndiameter(got)\n\n[1] 85\n\n# Q6\narticulation_points(got)\n\n+ 11/107 vertices, named, from f76bd92:\n [1] Oberyn   Davos    Kevan    Bran     Robb     Belwas   Daenerys Tyrion  \n [9] Jaime    Craster  Jon     \n\nlength(articulation_points(got)) / vcount(got)\n\n[1] 0.1028037",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Network statistics</span>"
    ]
  },
  {
    "objectID": "chapters/02_network_statistics.html#community-detection",
    "href": "chapters/02_network_statistics.html#community-detection",
    "title": "2  Network statistics",
    "section": "2.4 Community detection",
    "text": "2.4 Community detection\nIdentifying communities or clusters in a graph is one of the most common analyses in network science. This is a way of identifying subgraphs containing more closely-related nodes, and it has many implications in different fields. In biology, for instance, this can be used to identify genes or proteins involved in the same biological process; in social network science, this can reveal individuals that share traits and/or interests.\nIn igraph, you can identify communities using a family of functions named cluster_*(), and each function detects communities using a different algorithm. The Infomap algorithm is arguably one of the most popular of them, and it’s available in the function cluster_infomap(). Let’s demonstrate it.\n\n# Create graph\ng &lt;- make_graph(\"Zachary\")\nplot(g)\n\n\n\n\n\n\n\n# Detect communities with Infomap\ncl &lt;- cluster_infomap(g)\ncl\n\nIGRAPH clustering infomap, groups: 3, mod: 0.4\n+ groups:\n  $`1`\n   [1]  1  2  3  4  8 10 12 13 14 18 20 22\n  \n  $`2`\n  [1]  5  6  7 11 17\n  \n  $`3`\n   [1]  9 15 16 19 21 23 24 25 26 27 28 29 30 31 32 33 34\n  \n\n\nIn the output of cluster_infomap(), we can observe that the Infomap algorithm identified 3 clusters, whose members are described below each cluster ID. You can also extract cluster membership for each node with the functions membership() and communities(), which return a vector or membership and a list, respectively.\n\n# Vector of cluster membership for each node\nmembership(cl)\n\n [1] 1 1 1 1 2 2 2 1 3 1 2 1 1 1 3 3 2 1 3 1 3 1 3 3 3 3 3 3 3 3 3 3 3 3\n\n# List of nodes that belong to each cluster\ncommunities(cl)\n\n$`1`\n [1]  1  2  3  4  8 10 12 13 14 18 20 22\n\n$`2`\n[1]  5  6  7 11 17\n\n$`3`\n [1]  9 15 16 19 21 23 24 25 26 27 28 29 30 31 32 33 34\n\n\nThe generic plot() function can also be used to quickly visualize the graph with clusters highlighted.\n\n# Visualize graph with communities highlighted\nplot(cl, g)\n\n\n\n\n\n\n\n\nIf you have communities detected with different algorithms, you can use the function compare() to calculate the distance between two community structures. To demonstrate, let’s detect communities using another very popular algorithm named Louvain.\n\n# Detect community with Louvain\ncl2 &lt;- cluster_louvain(g)\n\n# Compare community structures\ncompare(cl, cl2)\n\n[1] 0.2727973\n\n\nThe function compare() can calculate distances between community structures using different methods. For more details on all methods, see the function’s help page (with ?compare).\n\n\n\n\n\n\nPractice\n\n\n\nUsing the Game of Thrones graph from the previous practice problems, identify communities using the Infomap, Louvain, Leiden, and label propagation algorithms. Then, answer the questions below.\n\nHow many clusters were detected by each algorithm?\nCalculate the distance between the community structures detected with Infomap and all other methods. What do you conclude based on the results?\n\n\n\n\n\n\n\nShow me the solutions\n\n\n\n\n\n\n# Q1\nclist &lt;- list(\n    Infomap = cluster_infomap(got),\n    Louvain = cluster_louvain(got),\n    Leiden = cluster_leiden(got),\n    Label_prop = cluster_label_prop(got)\n)\n\nlengths(clist)\n\n   Infomap    Louvain     Leiden Label_prop \n         7          7         31          8 \n\n# Q2\nlist(\n    compare(clist$Infomap, clist$Louvain),\n    compare(clist$Infomap, clist$Leiden),\n    compare(clist$Infomap, clist$Label_prop)\n)\n\n[[1]]\n[1] 0\n\n[[2]]\n[1] 0.9703974\n\n[[3]]\n[1] 0.1900617",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Network statistics</span>"
    ]
  },
  {
    "objectID": "chapters/02_network_statistics.html#session-information",
    "href": "chapters/02_network_statistics.html#session-information",
    "title": "2  Network statistics",
    "section": "Session information",
    "text": "Session information\nThis chapter was created under the following conditions:\n\n\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.2 (2023-10-31)\n os       Ubuntu 22.04.3 LTS\n system   x86_64, linux-gnu\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       Europe/Brussels\n date     2024-04-19\n pandoc   3.1.1 @ /usr/lib/rstudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package     * version date (UTC) lib source\n cli           3.6.2   2023-12-11 [1] CRAN (R 4.3.2)\n colorspace    2.1-0   2023-01-23 [1] CRAN (R 4.3.2)\n digest        0.6.34  2024-01-11 [1] CRAN (R 4.3.2)\n dplyr       * 1.1.4   2023-11-17 [1] CRAN (R 4.3.2)\n evaluate      0.23    2023-11-01 [1] CRAN (R 4.3.2)\n fansi         1.0.6   2023-12-08 [1] CRAN (R 4.3.2)\n fastmap       1.1.1   2023-02-24 [1] CRAN (R 4.3.2)\n forcats     * 1.0.0   2023-01-29 [1] CRAN (R 4.3.2)\n generics      0.1.3   2022-07-05 [1] CRAN (R 4.3.2)\n ggplot2     * 3.5.0   2024-02-23 [1] CRAN (R 4.3.2)\n glue          1.7.0   2024-01-09 [1] CRAN (R 4.3.2)\n gtable        0.3.4   2023-08-21 [1] CRAN (R 4.3.2)\n here        * 1.0.1   2020-12-13 [1] CRAN (R 4.3.2)\n hms           1.1.3   2023-03-21 [1] CRAN (R 4.3.2)\n htmltools     0.5.7   2023-11-03 [1] CRAN (R 4.3.2)\n htmlwidgets   1.6.4   2023-12-06 [1] CRAN (R 4.3.2)\n igraph      * 2.0.1.1 2024-01-30 [1] CRAN (R 4.3.2)\n igraphdata  * 1.0.1   2015-07-13 [1] CRAN (R 4.3.2)\n jsonlite      1.8.8   2023-12-04 [1] CRAN (R 4.3.2)\n knitr         1.45    2023-10-30 [1] CRAN (R 4.3.2)\n lifecycle     1.0.4   2023-11-07 [1] CRAN (R 4.3.2)\n lubridate   * 1.9.3   2023-09-27 [1] CRAN (R 4.3.2)\n magrittr      2.0.3   2022-03-30 [1] CRAN (R 4.3.2)\n munsell       0.5.0   2018-06-12 [1] CRAN (R 4.3.2)\n pillar        1.9.0   2023-03-22 [1] CRAN (R 4.3.2)\n pkgconfig     2.0.3   2019-09-22 [1] CRAN (R 4.3.2)\n purrr       * 1.0.2   2023-08-10 [1] CRAN (R 4.3.2)\n R6            2.5.1   2021-08-19 [1] CRAN (R 4.3.2)\n readr       * 2.1.5   2024-01-10 [1] CRAN (R 4.3.2)\n rlang         1.1.3   2024-01-10 [1] CRAN (R 4.3.2)\n rmarkdown     2.25    2023-09-18 [1] CRAN (R 4.3.2)\n rprojroot     2.0.4   2023-11-05 [1] CRAN (R 4.3.2)\n rstudioapi    0.15.0  2023-07-07 [1] CRAN (R 4.3.2)\n scales        1.3.0   2023-11-28 [1] CRAN (R 4.3.2)\n sessioninfo   1.2.2   2021-12-06 [1] CRAN (R 4.3.2)\n stringi       1.8.3   2023-12-11 [1] CRAN (R 4.3.2)\n stringr     * 1.5.1   2023-11-14 [1] CRAN (R 4.3.2)\n tibble      * 3.2.1   2023-03-20 [1] CRAN (R 4.3.2)\n tidyr       * 1.3.1   2024-01-24 [1] CRAN (R 4.3.2)\n tidyselect    1.2.0   2022-10-10 [1] CRAN (R 4.3.2)\n tidyverse   * 2.0.0   2023-02-22 [1] CRAN (R 4.3.2)\n timechange    0.3.0   2024-01-18 [1] CRAN (R 4.3.2)\n tzdb          0.4.0   2023-05-12 [1] CRAN (R 4.3.2)\n utf8          1.2.4   2023-10-22 [1] CRAN (R 4.3.2)\n vctrs         0.6.5   2023-12-01 [1] CRAN (R 4.3.2)\n withr         3.0.0   2024-01-16 [1] CRAN (R 4.3.2)\n xfun          0.42    2024-02-08 [1] CRAN (R 4.3.2)\n yaml          2.3.8   2023-12-11 [1] CRAN (R 4.3.2)\n\n [1] /home/faalm/R/x86_64-pc-linux-gnu-library/4.3\n [2] /usr/local/lib/R/site-library\n [3] /usr/lib/R/site-library\n [4] /usr/lib/R/library\n\n──────────────────────────────────────────────────────────────────────────────",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Network statistics</span>"
    ]
  },
  {
    "objectID": "chapters/03_network_modeling.html",
    "href": "chapters/03_network_modeling.html",
    "title": "3  Network modelling and hypothesis testing",
    "section": "",
    "text": "3.1 Mathematical graph models\nTo characterize the structure of graphs, multiple mathematical models have been developed. These models are used for a variety of purposes, including assessing the significance of observed properties, and studying mechanisms that led to some observed properties in a particular data set. In this section, we will explore some of the most commonly used graph models.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Network modelling and hypothesis testing</span>"
    ]
  },
  {
    "objectID": "chapters/03_network_modeling.html#mathematical-graph-models",
    "href": "chapters/03_network_modeling.html#mathematical-graph-models",
    "title": "3  Network modelling and hypothesis testing",
    "section": "",
    "text": "3.1.1 Random graphs\nClassical random graph models were established by Erdős and Rényi (Erdős and Rényi 1959, 1960, 1961), and later slightly adapted by Gilbert (Gilbert 1959). In these models, a graph with N nodes is created such that, for each pair of nodes, there exists an edge with probability between 0 and 1.\nIn igraph, these graphs can be simulated with the function sample_gnp(), and you only need to specify the number of nodes in the graph, and the probability for drawing an edge between two arbitrary nodes. To demonstrate it, let’s create a random graph according to the Erdős-Rényi model with 100 nodes and connection probability of 0.02. We will also plot the degree distribution of this graph.\n# Simulate a random graph (Erdős-Rényi model) with p = 0.02\ng_er &lt;- sample_gnp(100, 0.02)\n\nplot(g_er, layout = layout_in_circle, vertex.label = NA)\nhist(degree(g_er), xlab = \"Degree\", ylab = \"Frequency\", main = \"\")\n\n\n\n\n\n\n\n\n\n\nIn a classical random graph G with \\(N\\) nodes, for large \\(N\\), the degree distribution will be approximated by a Poisson distribution with mean \\(c\\), where \\(c = pN\\). This is quite intuitive, considering that the degree of any node is distributed as a binomial random variable with parameters \\(N-1\\) and \\(p\\). For example, in the graph we simulated above, the expected mean degree is \\(c = (100-1) \\times 0.02 = 1.98\\). Let’s verify is this is indeed what we observe.\n\n# Calculate mean degree of the simulated random graph\nmean(degree(g_er))\n\n[1] 1.88\n\n\nWe can see that the mean degree is indeed very close to the expected value. Other properties of classical random graphs include their small average shortest-path distances, and low clustering coefficient. Let’s verify that.\n\n# Calculate average shortest-path distance and diameter\nmean_distance(g_er)\n\n[1] 5.065434\n\ndiameter(g_er)\n\n[1] 11\n\n# Calculate clustering coefficient\ntransitivity(g_er)\n\n[1] 0\n\n\n\n\n\n\n\n\nPractice\n\n\n\nSimulate three classical random graphs with 500 nodes and p = 0.02, 0.05, and 0.1, respectively. Then, answer the questions below:\n\nWhat do their degree distributions look like?\nAre mean degrees of all graphs close to the expected values?\n\n\n\n\n\n\n\nShow me the solutions\n\n\n\n\n\n\n# Q1\ng1 &lt;- sample_gnp(500, 0.02)\ng2 &lt;- sample_gnp(500, 0.05)\ng3 &lt;- sample_gnp(500, 0.1)\n\nhist(degree(g1))\n\n\n\n\n\n\n\nhist(degree(g2))\n\n\n\n\n\n\n\nhist(degree(g3))\n\n\n\n\n\n\n\n# Q2\ndegree_df &lt;- data.frame(\n    expected = 499 * c(0.02, 0.05, 0.1),\n    observed = c(mean(degree(g1)), mean(degree(g2)), mean(degree(g3)))\n)\ndegree_df\n\n  expected observed\n1     9.98    9.724\n2    24.95   24.804\n3    49.90   49.772\n\n\n\n\n\n\n\n\n\n3.1.2 Generalized random graphs\nThe graph model proposed by Erdős-Rényi consists in assigning a common characteristic to a collection of graphs, that is, that the size of the graphs G be equal to some fixed \\(N_e\\). This formulation can be easily generalized by changing the characteristic that should be fixed in all graphs of a collection. Besides network size, the most common characteristic that researchers choose to set to fixed is the degree sequence. This means that we can create graphs that are different, but have the same degree sequence.\nIn igraph, you can create graphs with a fixed degree sequence using the function sample_degseq(). To demonstrate it, let’s create a graph with 8 nodes, with half of the nodes having degree \\(d = 2\\), and the other half with degree \\(d = 3\\).\n# Define degree sequence\ndseq &lt;- c(rep(2, 4), rep(3, 4))\n\n# Create two graphs with the same pre-defined degree sequence\ng1 &lt;- sample_degseq(dseq, method = \"vl\")\ng2 &lt;- sample_degseq(dseq, method = \"vl\")\n\nplot(g1)\nplot(g2)\n\n\n\n\n\n\n\n\n\n\nNote that, although the degree sequences are the same, these graphs are different:\n\n# Are graphs isomorphic (i.e., equal)?\nisomorphic(g1, g2)\n\n[1] FALSE\n\n\nIt is also important to keep in mind that, while the the degree sequence is fixed, all other network characteristics are free to vary from one graph to the other. For example, let’s create a graph that has the same degree sequence of the yeast protein-protein interaction network, and then compare some properties of the original and the simulated networks.\n\n# Get original network\ndata(yeast)\n\n# Simulate graph with the same degree sequence\nyeast_sim &lt;- sample_degseq(degree(yeast), method = \"vl\")\n\n# Compare properties\nprop_comp &lt;- data.frame(\n    mean_degree = c(mean(degree(yeast)), mean(degree(yeast_sim))),\n    diam = c(diameter(yeast), diameter(yeast_sim)),\n    cc = c(transitivity(yeast), transitivity(yeast_sim))\n)\n\nprop_comp\n\n  mean_degree diam         cc\n1    9.059992   15 0.46861779\n2    9.059992    8 0.04005188\n\n\nAs we can see, although the mean degree (and the entire degree distribution) is the same, the diameter and clustering coefficient of the graphs are completely different.\n\n\n\n\n\n\nPractice\n\n\n\nUse the code below to load a network containing interactions between amino acids in the immunoglobulin protein.\n\ndata(immuno)\n\nThen, simulate a network that has the same degree sequence of the immuno network and compare the original and the simulated network in terms of their:\n\nmean degree\nmean betweenness\ndiameter\nclustering coefficient\naverage shortest-path distances\n\nWhat properties are the same and what properties are different?\n\n\n\n\n\n\nShow me the solutions\n\n\n\n\n\n\n# Get original network\ndata(immuno)\n\n# Simulate graph with the same degree sequence\nimmuno_sim &lt;- sample_degseq(degree(immuno), method = \"vl\")\n\n# Compare properties\nprop_comp &lt;- data.frame(\n    mean_degree = c(mean(degree(immuno)), mean(degree(immuno_sim))),\n    mean_betweenness = c(mean(betweenness(immuno)), mean(betweenness(immuno_sim))),\n    diam = c(diameter(immuno), diameter(immuno_sim)),\n    cc = c(transitivity(immuno), transitivity(immuno_sim)),\n    sp = c(mean_distance(immuno), mean_distance(immuno_sim)),\n    row.names = c(\"original\", \"simulated\")\n)\n\nprop_comp\n\n          mean_degree mean_betweenness diam          cc        sp\noriginal     9.574468         9873.342   34 0.485116612 16.016490\nsimulated    9.574468         1607.125    5 0.005932897  3.444296\n\n\n\n\n\n\n\n\n\n3.1.3 Small-world models\nAs the field of network science evolved, researchers started to focus on developing models that could more accurately describe real-world networks. The first of this family of models is the ‘small-world’ network model proposed by Watts and Strogatz (Watts and Strogatz 1998), who observed that many networks in the real world display high levels of clustering, but small distances between most nodes.\nTo make a network graph with both of these features, Watts and Strogatz suggested starting with a lattice-like graph, then randomly changing (or ‘rewiring’) a few connections. Here’s how it works: we begin with a set of \\(N\\) nodes, arranged in a periodic fashion, and join each node to \\(r\\) of its neighbors to each side. Then, for each edge, independently and with probability p, one end of that edge will be moved to be incident to another node, where that new node is chosen uniformly, but with attention to avoid the construction of loops and multi-edges.\nIn igraph, small-world networks can be simulated using the function sample_smallworld(). To demonstrate it, let’s create a small-world network with \\(N = 25\\) nodes, neighborhoods of size \\(r = 5\\), and rewiring probability \\(p = 0.05\\).\n\n# Simulate small-world network with N = 25, r = 5, p = 0.05\ng_sw &lt;- sample_smallworld(1, 25, 5, 0.05)\nplot(g_sw, vertex.label = NA)\n\n\n\n\n\n\n\n\nNow, to understand the effect of rewiring the initial lattice, let’s create the lattice alone and explore its properties.\n\n# Create initial lattice alone (N = 100 nodes)\ng_lattice &lt;- sample_smallworld(1, 100, 5, 0)\n\n# Explore lattice's properties\nlist(\n    cc = transitivity(g_lattice),\n    diameter = diameter(g_lattice),\n    sp_distances = mean_distance(g_lattice)\n)\n\n$cc\n[1] 0.6666667\n\n$diameter\n[1] 10\n\n$sp_distances\n[1] 5.454545\n\n\nWe can that, in the initial lattice, the clustering coefficient is high, but the network’s diameter and average shortest-path distance is also quite considerable. To resemble real-world networks (with small distances between most nodes), Watts and Strogatz introduced the edge rewiring, which aims at reducing the distance between nodes while preserving the clustering coefficient.\n\n# Introduce rewiring with p = 0.05 to the initial lattice\ng_rewired &lt;- sample_smallworld(1, 100, 5, 0.05)\n\nlist(\n    cc = transitivity(g_rewired),\n    diameter = diameter(g_rewired),\n    sp_distances = mean_distance(g_rewired)\n)\n\n$cc\n[1] 0.5149648\n\n$diameter\n[1] 5\n\n$sp_distances\n[1] 2.777778\n\n\nAs we can observe, rewiring edges with probability \\(P = 0.05\\) leads to a much smaller diameter and average shortest-path distances. But what happens if we increase the probability \\(P\\)? To explore that, let’s simulate small-world networks with \\(N = 1000\\) nodes, \\(r = 10\\), and increasingly large probability \\(P\\). For each value of \\(P\\), we will simulate 50 networks and calculate the mean clustering coefficient.\n\n# Define sequence of P and number of replications per P\nsteps &lt;- seq(-4, -0.5, 0.1)\np &lt;- 10^steps\nnreps &lt;- 50\n\n# Simulate networks and get mean clustering coefficient in 50 replications\ncc_sim &lt;- sapply(p, function(x) {\n    cc &lt;- sapply(seq_len(nreps), function(y) {\n        transitivity(sample_smallworld(1, 1000, 10, x))\n    })\n    return(mean(cc))\n})\n\n# Visualize results\npdata &lt;- data.frame(p = p, cc = cc_sim / max(cc_sim))\nggplot(pdata, aes(x = p, y = cc)) +\n    geom_line() +\n    theme_bw() +\n    scale_x_log10()\n\n\n\n\n\n\n\n\nThe figure shows that the clustering coefficient remains high for a considerable range of \\(P\\).\n\n\n\n\n\n\nPractice\n\n\n\nRepeat the same simulation as above, but instead of calculating the mean clustering coefficient in 50 networks for each value \\(P\\), calculate the mean average shortest-path distance.\nThen, recreate the line plot above, but now with two lines (in different colors) indicating how clustering coefficients and average shortest-path distances vary as a function of \\(P\\). What do you conclude?\n\n\n\n\n\n\nShow me the solutions\n\n\n\n\n\n\n# Simulate networks and get mean clustering coefficient in 50 replications\nsp_sim &lt;- sapply(p, function(x) {\n    sp &lt;- sapply(seq_len(nreps), function(y) {\n        mean_distance(sample_smallworld(1, 1000, 10, x))\n    })\n    return(mean(sp))\n})\n\n# Visualize results\npdata &lt;- data.frame(\n    p = rep(p, 2),\n    stat = c(cc_sim / max(cc_sim), sp_sim / max(sp_sim)),\n    line = rep(c(\"CC\", \"SP\"), each = length(p))\n)\n\nggplot(pdata, aes(x = p, y = stat)) +\n    geom_line(aes(color = line)) +\n    theme_bw() +\n    scale_x_log10()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n3.1.4 Preferential attachment models\nOver the past few decades, network scientists have tried to develop models that could mimic how networks grow over time. Classical examples of networks that evolve over time are the World Wide Web, citation networks, and biological networks (e.g., protein-protein interaction and gene regulatory networks). As pioneers in this field, Barabási and Albert (1999) were intrigued by the growth of the World Wide Web, and they noticed that pages that are cited by many other pages tend to accumulate increasingly greater number of links over time. This property, now widely known as the ‘rich get richer’ principle, means that the more edges a node has, the more likely it is to gain even more edges over time.\nModels based on this assumption are called preferential attachment models, with the Barabási-Albert (BA) model arguably being the most famous one. In the BA model, we start with a graph \\(G\\) with \\(N_n\\) nodes and \\(N_e\\) edges. Then, at each stage \\(t = 1,2,...\\), the current graph \\(G_t\\) is modified to create a new graph \\(G_{t+1}\\) by adding a new node of degree \\(m \\ge 1\\), which means that the new node will have \\(m\\) connections to \\(m\\) different nodes in \\(G_t\\). The probability that the new node will be connected to any node \\(i\\) is\n\\[\np_i = \\frac{k_i}{\\sum_j k_j}\n\\]\nwhere \\(k_i\\) is the degree of node \\(i\\) and the sum is made over all nodes in graph \\(G_t\\). This indicates that new nodes are connected to existing nodes in a manner preferential to those with highest degrees.\nIn igraph, we can simulate a network under the BA model using the function sample_pa(). To demonstrate it, let’s create a graph with 100 nodes and \\(m = 1\\) new edges added for each node. Let’s also plot the simulated graph and its degree distribution.\n# Create a network with N = 100 and m = 1 under the BA model\ng_ba &lt;- sample_pa(100, m = 1, directed = FALSE)\n\n# Plot graph (circular layout) and degree distribution\nplot(g_ba, layout = layout_in_circle, vertex.label = NA)\nhist(degree(g_ba), xlab = \"Degree\", ylab = \"Frequency\")\n\n\n\n\n\n\n\n\n\n\nAs we can see on the plots, there is a small number of nodes with very high degree (the so-called ‘hubs’), while most nodes have very low degree. Let’s take a look at a quick summary of the degree distribution:\n\nsummary(degree(g_ba))\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   1.00    1.00    1.00    1.98    2.00   10.00 \n\n\nMost nodes have degree of no more than two, while some nodes have (comparatively) very large degrees.\nA major difference between preferential attachment models and classical random graphs is that, as the number of stages \\(t\\) tend to infinity, the degree distributions of the graphs tend to a power-law form \\(d^{-\\alpha}\\), with \\(\\alpha=3\\). Nevertheless, the BA model shares some similarities with its classical counterparts, such as the tendency to generate networks with small average shortest-path distances and low clustering coefficient. Let’s verify that:\n\nmean_distance(g_ba)\n\n[1] 5.806869\n\ndiameter(g_ba)\n\n[1] 12\n\ntransitivity(g_ba)\n\n[1] 0",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Network modelling and hypothesis testing</span>"
    ]
  },
  {
    "objectID": "chapters/03_network_modeling.html#assessing-the-significance-of-graph-features",
    "href": "chapters/03_network_modeling.html#assessing-the-significance-of-graph-features",
    "title": "3  Network modelling and hypothesis testing",
    "section": "3.2 Assessing the significance of graph features",
    "text": "3.2 Assessing the significance of graph features\nFrom a statistical hypothesis testing perspective, the models described in the previous sections are very useful to assess the significance of network graph characteristics. For instance, suppose we have a graph inferred from data and we are interested in some structural characteristic (e.g., clustering coefficient, number of communities, etc). A standard analysis is to investigate whether the observed characteristic is ‘significant’ (i.e., more extreme than the expected by chance). In this context, we can use the network models described above are used to create a reference distribution to which we compare our observed values. Below, we will demonstrate how this works with some use cases.\n\n3.2.1 Use case 1: number of communities in a network\nIn the previous chapter, we explored community detection algorithms using the karate club network as an example data set. Using the greedy optimization of modularity algorithm (in the function cluster_fast_greedy()), we identify three communities in this network, as demonstrated below.\n\n# Get karate club network and detect communities with infomap\ng &lt;- make_graph(\"Zachary\")\n\nlength(cluster_fast_greedy(g))\n\n[1] 3\n\n\nA natural question we might ask ourselves is whether this number is somehow unexpected. To test this hypothesis, we will use Monte Carlo methods to compare the observed number of communities to a reference distribution consisting of random graphs of same order (\\(N_n = 34\\) nodes) and size (\\(N_e\\) = 78 edges) as the karate network. Let’s first extract the order and size of the original network.\n\n# Get number of nodes and edges\nnn &lt;- vcount(g)\nne &lt;- ecount(g)\n\nNext, over 1000 trials, we will generate classical random graphs of same order and size, and detect communities using the greedy optimization of modularity algorithm.\n\n# Create 1000 classical random graphs and detect communities\nnull_comm &lt;- sapply(seq_len(1000), function(x) {\n    rg &lt;- sample_gnm(nn, ne)\n    ncomm &lt;- length(cluster_fast_greedy(rg))\n    return(ncomm)\n})\n\nNow, let’s visualize the probability of finding each number of communities in our random networks of same order and size.\n\n# Visualize nulls\ncounts &lt;- table(null_comm) / 1000\nbarplot(counts)\n\n\n\n\n\n\n\n\nThe figure shows that it’s very unlikely to find the number of communities we observed from the perspective of random graphs of fixed size.\n\n\n\n\n\n\nPractice\n\n\n\nIn the example above, we assessed the significance of the observed number of communities detected with cluster_fast_greedy() by comparing it to a null distribution of communities detected from classical random graphs. Repeat the same procedure, but now use generalized random graphs constrained to have the same degree distribution as the original karate club network.\nIs the observed number of communities also significant using this alternative model?\n\n\n\n\n\n\nShow me the solutions\n\n\n\n\n\n\n# Find communities in 1000 random graphs of same degree distribution\ndegs &lt;- degree(g)\nnull_comm2 &lt;- sapply(seq_len(1000), function(x) {\n    grg &lt;- sample_degseq(degs, method = \"vl\")\n    ncomm &lt;- length(cluster_fast_greedy(grg))\n    return(ncomm)\n})\n\ncounts2 &lt;- table(null_comm2) / 1000\nbarplot(counts2)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n3.2.2 Use case 2: small-world properties\nMany neuroscientists have reported that small-world properties can be observed in network-based representations of the brain. Recall that small-world networks have high levels of clustering, but small distances between most nodes. Hence, similarly to what we did in our previous use case, we could compare the observed clustering coefficient and average shortest-path distances to null distributions derived from classical random graphs.\nTo demonstrate this, we will use the macaque data set, which contains a directed network (45 nodes and 463 edges) of established functional connections between brain areas involved in the tactile function of the visual cortex in macaque monkeys (Négyessy et al. 2006).\n\n# Load data and take a quick look at it\ndata(macaque)\nsummary(macaque)\n\nIGRAPH f7130f3 DN-- 45 463 -- \n+ attr: Citation (g/c), Author (g/c), shape (v/c), name (v/c)\n\n\nTo calculate clustering coefficients, we will use an extension of the method implemented in transitivity() that is more suitable for directed graphs, implemented in the function below:\n\n# Define function to calculate clustering coefficient for directed graphs\ncc_dir &lt;- function(graph) {\n    A &lt;- as.matrix(as_adjacency_matrix(graph))\n    S &lt;- A + t(A)\n    deg &lt;- degree(graph, mode = \"total\")\n    num &lt;- diag(S %*% S %*% S)\n    denom &lt;- diag(A %*% A)\n    denom &lt;- 2 * (deg * (deg - 1) - 2 * denom)\n    cl &lt;- mean(num / denom)\n    \n    return(cl)\n}\n\nThen, over 1000 trials, we will simulate directed random graphs and get null distributions of clustering coefficients and average shortest-path lengths.\n\n# Define parameters\nnn &lt;- vcount(macaque)\nne &lt;- ecount(macaque)\n\n# Generate null distributions and store them in a 2-column data frame\nnulls &lt;- lapply(seq_len(1000), function(x) {\n    rg &lt;- sample_gnm(nn, ne, directed = TRUE)\n    df &lt;- data.frame(cc = cc_dir(rg), sp = mean_distance(rg))\n})\nnulls &lt;- Reduce(rbind, nulls)\n\nNext, let’s compare our observed values to the null distributions.\n\n# Observed values\nlist(cc = cc_dir(macaque), sp = mean_distance(macaque))\n\n$cc\n[1] 0.5501073\n\n$sp\n[1] 2.148485\n\n# Summary of nulls\nsummary(nulls$cc)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n 0.2166  0.2304  0.2341  0.2341  0.2378  0.2513 \n\nsummary(nulls$sp)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  1.814   1.828   1.833   1.833   1.838   1.863 \n\n\nWe can see that our observed values fall far outside the range of these random graphs. The observed clustering coefficient is higher than expected from a random network. However, the average shortest-path distance is also greater than expected, which is not what we expect from a small-world network. Hence, we do not have very strong evidence in support of small-world properties in this network.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Network modelling and hypothesis testing</span>"
    ]
  },
  {
    "objectID": "chapters/03_network_modeling.html#session-information",
    "href": "chapters/03_network_modeling.html#session-information",
    "title": "3  Network modelling and hypothesis testing",
    "section": "Session information",
    "text": "Session information\nThis chapter was created under the following conditions:\n\n\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.2 (2023-10-31)\n os       Ubuntu 22.04.3 LTS\n system   x86_64, linux-gnu\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       Europe/Brussels\n date     2024-04-19\n pandoc   3.1.1 @ /usr/lib/rstudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package     * version date (UTC) lib source\n cli           3.6.2   2023-12-11 [1] CRAN (R 4.3.2)\n colorspace    2.1-0   2023-01-23 [1] CRAN (R 4.3.2)\n digest        0.6.34  2024-01-11 [1] CRAN (R 4.3.2)\n dplyr       * 1.1.4   2023-11-17 [1] CRAN (R 4.3.2)\n evaluate      0.23    2023-11-01 [1] CRAN (R 4.3.2)\n fansi         1.0.6   2023-12-08 [1] CRAN (R 4.3.2)\n farver        2.1.1   2022-07-06 [1] CRAN (R 4.3.2)\n fastmap       1.1.1   2023-02-24 [1] CRAN (R 4.3.2)\n forcats     * 1.0.0   2023-01-29 [1] CRAN (R 4.3.2)\n generics      0.1.3   2022-07-05 [1] CRAN (R 4.3.2)\n ggplot2     * 3.5.0   2024-02-23 [1] CRAN (R 4.3.2)\n glue          1.7.0   2024-01-09 [1] CRAN (R 4.3.2)\n gtable        0.3.4   2023-08-21 [1] CRAN (R 4.3.2)\n here        * 1.0.1   2020-12-13 [1] CRAN (R 4.3.2)\n hms           1.1.3   2023-03-21 [1] CRAN (R 4.3.2)\n htmltools     0.5.7   2023-11-03 [1] CRAN (R 4.3.2)\n htmlwidgets   1.6.4   2023-12-06 [1] CRAN (R 4.3.2)\n igraph      * 2.0.1.1 2024-01-30 [1] CRAN (R 4.3.2)\n igraphdata  * 1.0.1   2015-07-13 [1] CRAN (R 4.3.2)\n jsonlite      1.8.8   2023-12-04 [1] CRAN (R 4.3.2)\n knitr         1.45    2023-10-30 [1] CRAN (R 4.3.2)\n labeling      0.4.3   2023-08-29 [1] CRAN (R 4.3.2)\n lattice       0.22-5  2023-10-24 [4] CRAN (R 4.3.1)\n lifecycle     1.0.4   2023-11-07 [1] CRAN (R 4.3.2)\n lubridate   * 1.9.3   2023-09-27 [1] CRAN (R 4.3.2)\n magrittr      2.0.3   2022-03-30 [1] CRAN (R 4.3.2)\n Matrix        1.6-3   2023-11-14 [4] CRAN (R 4.3.2)\n munsell       0.5.0   2018-06-12 [1] CRAN (R 4.3.2)\n pillar        1.9.0   2023-03-22 [1] CRAN (R 4.3.2)\n pkgconfig     2.0.3   2019-09-22 [1] CRAN (R 4.3.2)\n purrr       * 1.0.2   2023-08-10 [1] CRAN (R 4.3.2)\n R6            2.5.1   2021-08-19 [1] CRAN (R 4.3.2)\n readr       * 2.1.5   2024-01-10 [1] CRAN (R 4.3.2)\n rlang         1.1.3   2024-01-10 [1] CRAN (R 4.3.2)\n rmarkdown     2.25    2023-09-18 [1] CRAN (R 4.3.2)\n rprojroot     2.0.4   2023-11-05 [1] CRAN (R 4.3.2)\n rstudioapi    0.15.0  2023-07-07 [1] CRAN (R 4.3.2)\n scales        1.3.0   2023-11-28 [1] CRAN (R 4.3.2)\n sessioninfo   1.2.2   2021-12-06 [1] CRAN (R 4.3.2)\n stringi       1.8.3   2023-12-11 [1] CRAN (R 4.3.2)\n stringr     * 1.5.1   2023-11-14 [1] CRAN (R 4.3.2)\n tibble      * 3.2.1   2023-03-20 [1] CRAN (R 4.3.2)\n tidyr       * 1.3.1   2024-01-24 [1] CRAN (R 4.3.2)\n tidyselect    1.2.0   2022-10-10 [1] CRAN (R 4.3.2)\n tidyverse   * 2.0.0   2023-02-22 [1] CRAN (R 4.3.2)\n timechange    0.3.0   2024-01-18 [1] CRAN (R 4.3.2)\n tzdb          0.4.0   2023-05-12 [1] CRAN (R 4.3.2)\n utf8          1.2.4   2023-10-22 [1] CRAN (R 4.3.2)\n vctrs         0.6.5   2023-12-01 [1] CRAN (R 4.3.2)\n withr         3.0.0   2024-01-16 [1] CRAN (R 4.3.2)\n xfun          0.42    2024-02-08 [1] CRAN (R 4.3.2)\n yaml          2.3.8   2023-12-11 [1] CRAN (R 4.3.2)\n\n [1] /home/faalm/R/x86_64-pc-linux-gnu-library/4.3\n [2] /usr/local/lib/R/site-library\n [3] /usr/lib/R/site-library\n [4] /usr/lib/R/library\n\n──────────────────────────────────────────────────────────────────────────────",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Network modelling and hypothesis testing</span>"
    ]
  },
  {
    "objectID": "chapters/03_network_modeling.html#references",
    "href": "chapters/03_network_modeling.html#references",
    "title": "3  Network modelling and hypothesis testing",
    "section": "References",
    "text": "References\n\n\n\n\nBarabási, Albert-László, and Réka Albert. 1999. “Emergence of Scaling in Random Networks.” Science 286 (5439): 509–12.\n\n\nErdős, Paul, and Alfréd Rényi. 1959. “On Random Graphs i.” Publ. Math. Debrecen 6 (290-297): 18.\n\n\n———. 1960. “On the Evolution of Random Graphs.” Publ. Math. Inst. Hung. Acad. Sci 5 (1): 17–60.\n\n\n———. 1961. “On the Strength of Connectedness of a Random Graph.” Acta Mathematica Hungarica 12 (1): 261–67.\n\n\nGilbert, Edgar N. 1959. “Random Graphs.” The Annals of Mathematical Statistics 30 (4): 1141–44.\n\n\nNégyessy, László, Tamás Nepusz, László Kocsis, and Fülöp Bazsó. 2006. “Prediction of the Main Cortical Areas and Connections Involved in the Tactile Function of the Visual Cortex by Network Analysis.” European Journal of Neuroscience 23 (7): 1919–30.\n\n\nWatts, Duncan J, and Steven H Strogatz. 1998. “Collective Dynamics of ‘Small-World’networks.” Nature 393 (6684): 440–42.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Network modelling and hypothesis testing</span>"
    ]
  },
  {
    "objectID": "chapters/04_network_visualization.html",
    "href": "chapters/04_network_visualization.html",
    "title": "4  Network visualization",
    "section": "",
    "text": "4.1 Tidy graph representations\nTo create plots using the ggplot plotting system, one needs to have tidy data in the long format (as in the tidyverse nomenclature), which is summarized below.\nTo convert igraph objects to a tidy data frame, you can use the tidygraph package, which offers a tidy API for graph manipulation. In particular, we are mostly interested in the function as_tbl_graph, which converts igraph objects to tbl_graph objects containing nodes and edges (with attributes, if any) in a tidy format. Let’s demonstrate it with the karate network we’ve been using in previous chapters.\n# Get karate club network\ng &lt;- make_graph(\"Zachary\")\n\n# Convert `igraph` object to tidy `tbl_graph`\ngraph_df &lt;- as_tbl_graph(g)\n\ngraph_df\n\n# A tbl_graph: 34 nodes and 78 edges\n#\n# An undirected simple graph with 1 component\n#\n# Node Data: 34 × 0 (active)\n#\n# Edge Data: 78 × 2\n   from    to\n  &lt;int&gt; &lt;int&gt;\n1     1     2\n2     1     3\n3     1     4\n# ℹ 75 more rows\nWe can see that this tbl_graph object contains only edge information, because the original igraph object does not contain node attributes. For example, let’s now do the same with the macaque network data from the igraphdata package.\ndata(macaque)\n\n# Convert `igraph` object to tidy `tbl_graph`\nmacaque_df &lt;- as_tbl_graph(macaque)\n\nmacaque_df\n\n# A tbl_graph: 45 nodes and 463 edges\n#\n# A directed simple graph with 1 component\n#\n# Node Data: 45 × 2 (active)\n   shape  name  \n   &lt;chr&gt;  &lt;chr&gt; \n 1 square V1    \n 2 square V2    \n 3 square V3    \n 4 square V3A   \n 5 square V4    \n 6 square V4t   \n 7 square VOT   \n 8 square VP    \n 9 square MT    \n10 square MSTd/p\n# ℹ 35 more rows\n#\n# Edge Data: 463 × 2\n   from    to\n  &lt;int&gt; &lt;int&gt;\n1     1     2\n2     1     3\n3     1     4\n# ℹ 460 more rows",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Network visualization</span>"
    ]
  },
  {
    "objectID": "chapters/04_network_visualization.html#plotting-networks",
    "href": "chapters/04_network_visualization.html#plotting-networks",
    "title": "4  Network visualization",
    "section": "4.2 Plotting networks",
    "text": "4.2 Plotting networks\nThe ggraph package is arguably one of the most popular R packages to visualize networks using the ggplot system. This package was designed to interoperate with tidygraph, and it can produce network visualizations from tbl_graph objects in many ways. In the sections below, we will explore the building blocks of plots produced with ggraph.\n\n4.2.1 Layouts\nWhen plotting networks, a very important step consists in choosing an appropriate layout to use. Layouts algorithms are algorithms that take a graph structure and return the x and y coordinates of the nodes.\nTo start, let’s create a basic network plot using the highschool data set, which contains friendship relationships among high school boys in 1957 and 1958. We will use the default layout.\n\n# Create `tbl_graph` object\ngdf &lt;- as_tbl_graph(highschool)\n\nggraph(gdf) +\n    geom_edge_link(aes(color = factor(year))) +\n    geom_node_point()\n\n\n\n\n\n\n\n\nBy default, the function ggraph() uses the “stress” layout, a slightly modified version of the stress-minimization algorithm Kamada-Kawai. However, ggraph() offers multiple layout algorithms, including internal igraph layout algorithms (available in igraph’s functions layout_with_*()). You can explore all available layouts by running ?create_layout().\nDifferent layout algorithms can be specified in the layout argument of the ggraph() function. For example, let’s recreate the network plot above, but now with the ‘kk’ layout (internal igraph layout).\n\nggraph(gdf, layout = \"kk\") +\n    geom_edge_link(aes(color = factor(year))) +\n    geom_node_point()\n\n\n\n\n\n\n\n\nIf you look at the documentation of the function igraph::layout_with_kk(), you will notice that this layout algorithm can take additional parameters (as do most layout algorithms). These additional parameters can be passed to ggraph() as well.\n\nggraph(gdf, layout = \"kk\", maxiter = 100) +\n    geom_edge_link(aes(color = factor(year))) +\n    geom_node_point()\n\n\n\n\n\n\n\n\nAlternatively, you can also use the function create_layout() to get a data frame of x and y coordinates for nodes based on a specific layout algorithm. Under the hood, this is what ggraph() does.\n\n# Get a data frame of x and y coordinates based on layout 'kk'\ncoords &lt;- create_layout(gdf, layout = \"kk\")\n\nhead(coords)\n\n# A tibble: 6 × 5\n       x     y .ggraph.orig_index circular .ggraph.index\n   &lt;dbl&gt; &lt;dbl&gt;              &lt;int&gt; &lt;lgl&gt;            &lt;int&gt;\n1  2.34  1.34                   1 FALSE                1\n2  2.72  1.84                   2 FALSE                2\n3  3.32  1.31                   3 FALSE                3\n4 -2.54  0.884                  4 FALSE                4\n5 -1.76  1.95                   5 FALSE                5\n6 -0.357 3.33                   6 FALSE                6\n\n# Plot network using the data frame of coordinates\nggraph(coords) + \n  geom_edge_link(aes(color = factor(year))) + \n  geom_node_point()\n\n\n\n\n\n\n\n\nggraph includes all layouts in the packages igraph and graphlayouts, as well as specialized layouts that are only available in ggraph. We will explore some layout options in the subsections below.\n\n\n\n\n\n\nPractice\n\n\n\n\nUsing the macaque network, create a network plot that matches the following requirements:\n\n\nLayout: ‘kk’\nEdge color: ‘gray80’\nNode color and shape should be mapped to node attribute shape.\n\nHint: mapping variables to plot aesthetics works just like in any other plot created with the ggplot system.\n\nRecreate the same plot as above, but now using the layouts ‘graphopt’, ‘circle’, and ‘fr’.\n\n\n\n\n\n\n\nShow me the solutions\n\n\n\n\n\n\ng &lt;- as_tbl_graph(macaque)\n\n# Q1\nggraph(g, layout = \"kk\") +\n    geom_edge_link(color = \"gray80\") +\n    geom_node_point(aes(shape = shape, color = shape))\n\n\n\n\n\n\n\n# Q2\nggraph(g, layout = \"graphopt\") +\n    geom_edge_link(color = \"gray80\") +\n    geom_node_point(aes(shape = shape, color = shape))\n\n\n\n\n\n\n\nggraph(g, layout = \"circle\") +\n    geom_edge_link(color = \"gray80\") +\n    geom_node_point(aes(shape = shape, color = shape))\n\n\n\n\n\n\n\nggraph(g, layout = \"fr\") +\n    geom_edge_link(color = \"gray80\") +\n    geom_node_point(aes(shape = shape, color = shape))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n4.2.1.1 Circular layouts\nSome relationships in network data are better visualized if represented in a circular fashion You can create circular representations by setting circular = TRUE in ggraph(). To demonstrate, let’s create the same kind of network plot, an arc diagram, in standard and circular layout.\n\n# 1) Arc diagram - standard representation\np1 &lt;- ggraph(gdf, layout = 'linear') + \n  geom_edge_arc(aes(colour = factor(year)))\n\n# 2) Chord diagram - circular representation\np2 &lt;- ggraph(gdf, layout = 'linear', circular = TRUE) + \n  geom_edge_arc(aes(colour = factor(year)))\n\np1 / p2\n\n\n\n\n\n\n\n\nYou may have noticed that the network layout (and everything else) remains the same in both plots, and the only difference is that the second plot was created by representing the layout in a circular fashion. Note also that representing a layout circularly often changes the “name” of the visualization (i.e., how people often refer to it). In this example, you can clearly see that a so-called chord diagram is simply an arc diagram represented circularly.\nAnother example of how circular representations can change a visualization’s “name” is the distinction between icicle plots and sunburst plots, both of which represent hierarchical data, but latter method does so in a circular fashion. To demonstrate, let’s create both plots using the flare data set, which contains a graph describing the class hierarchy for the Flare ActionScript visualization library.\n\n# Create `tbl_graph` object from flare data set\nfg &lt;- tbl_graph(flare$vertices, flare$edges)\n\n# 1) Icicle plot - standard representation\np1 &lt;- ggraph(fg, \"partition\") +\n    geom_node_tile(aes(fill = depth), linewidth = 0.2)\n\n# 1) Sunburst plot - standard representation\np2 &lt;- ggraph(fg, \"partition\", circular = TRUE) +\n    geom_node_arc_bar(aes(fill = depth), linewidth = 0.2) +\n    coord_fixed()\n\np1 + p2\n\n\n\n\n\n\n\n\n\n\n4.2.1.2 Node-edge layouts\nWhen people think about network visualizations, node-edge diagrams are arguably the first picture that comes to their mind. igraph offers many layout algorithms to create such plots, each of them optimized for a different scenario. Thus, there is no such thing as “the best layout algorithm”, and you should try different algorithms for your network to see what looks better.\nTo demonstrate some of these family of algorithms and how you can explore how the plots they create look like, we will store layout names in a vector and loop through them, passing them as input to the layout argument of ggraph() in each iteration. Recall that this is possible because different layouts can be used by simply changing the input to the layout argument.\n\n# Define layout names we want to try\nlayouts &lt;- c(\"stress\", \"fr\", \"lgl\", \"graphopt\")\n\n# Create the same plot, but changing input to `layout` argument\nplots &lt;- lapply(layouts, function(x) {\n    \n    p &lt;- ggraph(highschool, layout = x) + \n        geom_edge_link(aes(colour = factor(year)), show.legend = FALSE) +\n        geom_node_point() + \n        labs(title = paste0('Layout: ', x))\n    \n    return(p)\n})\n\nwrap_plots(plots, nrow = 2)\n\n\n\n\n\n\n\n\n\n\n4.2.1.3 Hive plots\nHive plots have become increasingly popular to visualize large networks, because they display nodes on radially distributed linear axes, each axis representing a level of a node attribute. For example, using the highschool data set, let’s create a variable friends indicating whether each person has few, medium, or many friends.\n\n# Add degree information to highschool network\nhs_graph &lt;- as_tbl_graph(highschool) |&gt;\n    mutate(degree = centrality_degree(mode = \"in\")) |&gt;\n    mutate(\n        friends = case_when(\n            degree &lt;5 ~ \"few\",\n            degree &gt;=15 ~ \"many\",\n            TRUE ~ \"medium\"\n        )\n    )\n\nhs_graph\n\n# A tbl_graph: 70 nodes and 506 edges\n#\n# A directed multigraph with 1 component\n#\n# Node Data: 70 × 2 (active)\n   degree friends\n    &lt;dbl&gt; &lt;chr&gt;  \n 1      2 few    \n 2      0 few    \n 3      0 few    \n 4      4 few    \n 5      5 medium \n 6      2 few    \n 7      2 few    \n 8      3 few    \n 9      4 few    \n10      4 few    \n# ℹ 60 more rows\n#\n# Edge Data: 506 × 3\n   from    to  year\n  &lt;int&gt; &lt;int&gt; &lt;dbl&gt;\n1     1    13  1957\n2     1    14  1957\n3     1    20  1957\n# ℹ 503 more rows\n\n\nNow, we can create a hive plot showing each level of the friends variable (few, many, and medium) as an axis, with nodes mapped to each axis sorted by their degrees.\n\n# Create a hive plot\nggraph(hs_graph, \"hive\", axis = friends, sort.by = degree) + \n    geom_edge_hive(aes(colour = factor(year))) + \n    geom_axis_hive(aes(colour = friends), linewidth = 2, label = FALSE) + \n    coord_fixed()\n\n\n\n\n\n\n\n\n\n\n4.2.1.4 Focal layouts\nFocal layouts are used to display all nodes relative to a central node (or group of nodes). The focal nodes can be, for example, nodes with high degree, or a node you want to highlight.\n\nggraph(highschool, \"focus\", focus = node_is_center()) + \n    ggforce::geom_circle(\n        data = data.frame(r = 1:5), \n        aes(x0 = 0, y0 = 0, r = r), \n        colour = \"grey\"\n    ) + \n    geom_edge_link() + \n    geom_node_point() + \n    coord_fixed()\n\n\n\n\n\n\n\n\n\n\n4.2.1.5 Hierarhical layouts\nHierarchical layouts are optimized to represent tree-like data, and ggraph offers several algorithms for such data, including ‘ciclepack’, ‘treemap’, ‘cactustree’, ‘tree’, and ‘dendrogram’. Here, we will focus on the most commonly used ones using the flare data set.\nThe ‘circlepack’ layout, like some other hierarchical layouts, can be used to display relations with enclosure and positions only, or with edges too. Let’s demonstrate both ways.\n\n# Create `tbl_graph` object\ngraph &lt;- tbl_graph(flare$vertices, flare$edges)\n\n# 1) Only enclosure and positions\np1 &lt;- ggraph(graph, \"circlepack\", weight = size) + \n    geom_node_circle(aes(fill = depth), size = 0.25, n = 50) + \n    coord_fixed()\n\n# 2) Include edges\np2 &lt;- ggraph(graph, \"circlepack\", weight = size) + \n    geom_edge_link() + \n    geom_node_point(aes(colour = depth)) +\n    coord_fixed()\n\np1 / p2\n\n\n\n\n\n\n\n\nThe same data can also be represented as a tree using the ‘tree’ layout.\n\nggraph(graph, \"tree\") +\n    geom_edge_diagonal()\n\n\n\n\n\n\n\n\nIn a tree representation, when node heights are important (with nested relations, as in hclust objects), you would probably prefer to use a ‘dendrogram’ layout instead. To demonstrate this, let’s create a dendrogram from the iris data set.\n\n# Create `hclust` object\ndendrogram &lt;- hclust(dist(iris[, 1:4]))\n\nggraph(dendrogram, \"dendrogram\", height = height) +\n    geom_edge_elbow()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPractice\n\n\n\nFor each of the data sets below, choose a suitable layout and plot them.\n\n# Data set 1\nds1 &lt;- hclust(dist(USArrests), \"average\")\n\n# Data set 2\ndata(UKfaculty)\nds2 &lt;- UKfaculty\n\n\n\n\n\n\n\nShow me the solutions\n\n\n\n\n\n\n# Data set 1\nggraph(ds1, \"dendrogram\", height = height) +\n    geom_edge_elbow()\n\n\n\n\n\n\n\n# Data set 2\nggraph(ds2, \"stress\") +\n    geom_edge_link(alpha = 0.5, linewidth = 0.2)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n4.2.2 Nodes and edges\nggraph offers different node and edge options with the family of functions geom_node_*() and geom_edge_*(). Each function from each family is used for a specific kind of visualization, and below we’re going to explore the main ones.\n\n4.2.2.1 Node options: geom_node_*()\nThe most common node geom is geom_node_point(), which is used to create classical node-edge diagrams. Let’s take a look at an example below.\n\ng &lt;- as_tbl_graph(highschool)\nggraph(g) +\n    geom_edge_link(color = \"gray70\") +\n    geom_node_point()\n\n\n\n\n\n\n\n\nThe function geom_node_voronoi() display nodes as cells from a voronoi tesselation, and it can be useful to show dominance of certain node types.\n\ngraph &lt;- create_notable('meredith') |&gt; \n    mutate(group = sample(c('A', 'B'), n(), TRUE))\n\nggraph(graph) + \n    geom_node_voronoi(aes(fill = group), max.radius = 1) + \n    geom_node_point() + \n    geom_edge_link() + \n    coord_fixed()\n\n\n\n\n\n\n\n\nThe function geom_node_tile() is typically used together with layout = 'treemap' and layout = 'partition'. Let’s see some examples.\n\n# Create `tbl_graph` from flare data set\ngraph &lt;- tbl_graph(flare$vertices, flare$edges)\n\n# 1) Icicle diagram\np1 &lt;- ggraph(graph, layout = 'partition') + \n    geom_node_tile(aes(y = y, fill = depth))\n\n# 2) Treemap\np2 &lt;- ggraph(graph, layout = 'treemap', weight = size) + \n    geom_node_tile(aes(fill = depth))\n\np1 / p2\n\n\n\n\n\n\n\n\nTo view all functions in the geom_node_*() family, you can execute ??ggraph::geom_node_.\n\n\n4.2.2.2 Edge options: geom_edge_*()\nAs we’ve seen before, the most common edge geom is geom_edge_link(), which simply draws a line between two nodes.\n\ng &lt;- as_tbl_graph(highschool)\n\nggraph(g) +\n    geom_edge_link(aes(color = factor(year)))\n\n\n\n\n\n\n\n\nIn case there are multiple edges between the same nodes, a better way of representing them would be using the functions geom_edge_fan() and geom_edge_parallel(), as demonstrated below.\n\n# 1) geom_edge_fan() - multi-edges as arcs with different curvature\np1 &lt;- ggraph(g) +\n    geom_edge_fan(aes(color = factor(year)))\n\n# 2) geom_edge_parallel() - multi-edges as parallel lines\np2 &lt;- ggraph(g) +\n    geom_edge_parallel(aes(color = factor(year)))\n\np1 / p2\n\n\n\n\n\n\n\n\nIn some cases, arcs are a better way of representing edges, either in a linear or circular representation. Arcs can be created with geom_edge_arc().\n\n# 1) geom_edge_arc(), linear\np1 &lt;- ggraph(g, layout = \"linear\") +\n    geom_edge_arc(aes(color = factor(year))) +\n    coord_fixed()\n\n# 2) geom_edge_arc(), circular\np2 &lt;- ggraph(g, layout = \"linear\", circular = TRUE) +\n    geom_edge_arc(aes(color = factor(year))) +\n    coord_fixed()\n\np1 / p2\n\n\n\n\n\n\n\n\nAnother technique for drawing edges is bundling, which consists in bundling edges that flow in the same direction to avoid clutter. Many bundling algorithms exist, but ggraph offers 3 algorithms: force-directed, edge path, and minimal, available in geoms geom_edge_bundle_force(), geom_edge_bundle_path(), and geom_edge_bundle_minimal(), respectively. Let’s demonstrate each of them.\n\n# Bundling with force-directed algorithm\np1 &lt;- ggraph(g) +\n    geom_edge_bundle_force()\n\n# Bundling with edge path algorithm\np2 &lt;- ggraph(g) +\n    geom_edge_bundle_path()\n\n# Bundling with minimal algorithm\np3 &lt;- ggraph(g) +\n    geom_edge_bundle_minimal()\n\np1 / p2 / p3\n\n\n\n\n\n\n\n\nTo visualize hierarchical data as a dendrogram, you can use geom_edge_elbow() or its smoother alternatives geom_edge_diagonal() and geom_edge_bend().\n\nh &lt;- hclust(dist(iris[, 1:4]))\n\n# Dendrogram, elbow\np1 &lt;- ggraph(h, layout = \"dendrogram\", height = height) +\n    geom_edge_elbow()\n\n# Dendrogram, diagonal\np2 &lt;- ggraph(h, layout = \"dendrogram\", height = height) +\n    geom_edge_diagonal()\n\n# Dendrogram, bend\np3 &lt;- ggraph(h, layout = \"dendrogram\", height = height) +\n    geom_edge_bend()\n\np1 + p2 + p3\n\n\n\n\n\n\n\n\nImportantly, many edge geoms (including geom_edge_elbow()) can take a strength argument (from 0 to 1; default = 1) that indicates how much the line deviates from a straight line. This way, you can plot a dendrogram with geom_edge_elbow() that looks similar to one created with geom_edge_diagonal().\n\nggraph(h, layout = \"dendrogram\", height = height) +\n    geom_edge_elbow(strength = 0.5)\n\n\n\n\n\n\n\n\nFinally, you can also decorate your edges with arrows and labels. To add arrows, you will use the arrow() function in the arrow argument of the edge geom. It’s also important to specify a cap in argument end_cap so that the arrows have some distance from terminal nodes. Here is an example:\n\n# Create 'bull' graph with {igraph} and add edge attributes\nbull &lt;- make_graph(\"Bull\")\nE(bull)$type &lt;- sample(c(\"friend\", \"foe\"), ecount(bull), TRUE)\ngbull &lt;- as_tbl_graph(bull)\n\n# Plot graph with edges\nggraph(gbull, layout = 'graphopt') + \n    geom_edge_link(\n        arrow = arrow(length = unit(4, 'mm')), \n        end_cap = circle(3, 'mm')\n    ) + \n    geom_node_point(size = 5)\n\n\n\n\n\n\n\n\nTo include edge labels in this same graph, you’d do:\n\nggraph(gbull, layout = 'graphopt') + \n    geom_edge_link(\n        aes(label = type),\n        angle_calc = \"along\",\n        label_dodge = unit(2.5, \"mm\"),\n        arrow = arrow(length = unit(4, 'mm')), \n        end_cap = circle(3, 'mm')\n    ) + \n    geom_node_point(size = 5)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPractice\n\n\n\nIn the plot above, with edges having labels and arrows, what happens if you remove the arguments angle_calc = \"along\" and label_dodge = unit(2.5, \"mm\")? Based on what you observe, what do these arguments control?\n\n\n\n\n\n\nShow me the solutions\n\n\n\n\n\n\n# Removing `label_dodge` -&gt; labels will be placed on top of the lines\nggraph(gbull, layout = 'graphopt') + \n    geom_edge_link(\n        aes(label = type),\n        angle_calc = \"along\",\n        arrow = arrow(length = unit(4, 'mm')), \n        end_cap = circle(3, 'mm')\n    ) + \n    geom_node_point(size = 5)\n\n\n\n\n\n\n\n# Removing `angle_calc` -&gt; labels will all have the same rotation\nggraph(gbull, layout = 'graphopt') + \n    geom_edge_link(\n        aes(label = type),\n        arrow = arrow(length = unit(4, 'mm')), \n        end_cap = circle(3, 'mm')\n    ) + \n    geom_node_point(size = 5)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Network visualization</span>"
    ]
  },
  {
    "objectID": "chapters/04_network_visualization.html#visualizing-large-networks",
    "href": "chapters/04_network_visualization.html#visualizing-large-networks",
    "title": "4  Network visualization",
    "section": "4.3 Visualizing large networks",
    "text": "4.3 Visualizing large networks\nIn real-world network data analyses, we often work with large networks. While visualizing very large networks is generally not recommended (because it’s hard to extract meaningful information from such visualizations), sometimes they can be useful to explore group structure in graphs. In this final section, we will use the Game of Thrones network we explored in previous chapters to demonstrate best practices to get the most out of network visualizations, especially for large networks.\nLet’s start by loading the data set and creating a simple node-edge diagram (or hairball) with default parameters.\n\n# Load data set\ngot &lt;- readRDS(here(\"data\", \"got.rds\"))\n\n# Get `tbl_graph` and plot it\ng &lt;- as_tbl_graph(got)\n\np1 &lt;- ggraph(g) + \n    geom_edge_link() +\n    geom_node_point()\n\np1\n\n\n\n\n\n\n\n\nThis is a relatively large network (N = 107 nodes), and a simple visualization with default parameters does not work so well. We can hardly extract any useful information from it. The first and very important thing you’d want to change in this plot would be node size and colors. It is considered standard practice to color nodes based on their shared properties (such as communities inferred with community detection algorithms), and to give them variables sizes based on their degree. Let’s do this.\n\n# Add `degree` and `cluster` node attributes\nV(got)$cluster &lt;- cluster_louvain(got) |&gt; membership() |&gt; as.character()\nV(got)$degree &lt;- degree(got)\n\ng &lt;- as_tbl_graph(got)\n\np2 &lt;- ggraph(g) + \n    geom_edge_link() +\n    geom_node_point(aes(size = degree, fill = cluster), shape = 21)\n\np2\n\n\n\n\n\n\n\n\nThis looks much better, right? But we can still improve it further. We can see that a part of the graph is densely connected, which makes it a bit cluttered. To make it look better, we can reduce line widths, and add a bit of transparency to the edges.\n\np3 &lt;- ggraph(g) + \n    geom_edge_link(linewidth = 0.2, alpha = 0.6) +\n    geom_node_point(aes(size = degree, fill = cluster), shape = 21)\n\np3\n\n\n\n\n\n\n\n\nLastly, we can also use a better color palette.\n\np4 &lt;- ggraph(g) + \n    geom_edge_link(linewidth = 0.2, alpha = 0.6) +\n    geom_node_point(aes(size = degree, fill = cluster), shape = 21) +\n    scale_fill_brewer(palette = \"Set1\")\n\np4\n\n\n\n\n\n\n\n\nBy simply changing the aesthetics of nodes and edges, this is how we made out plot look better:\n\n\n\n\n\n\n\n\n\nBesides changing node and edge aesthetics, playing with different layouts is also very important when visualizing large networks. The default layouts in ggraph (‘stress’ for most networks, and ‘sparse_stress’ for very large networks) are excellent layouts that generally work well, but you might want to test other approaches for large networks.\nA common approach consists in using focal layouts to emphasize certain nodes. This can be done using layout = \"focus\" (to focus on a central node) or layout = \"centrality\" (similar to ‘focus’, but using a centrality measure).\n\n# 'focus' layout\np1 &lt;- ggraph(g, layout = \"focus\", focus = node_is_center()) + \n    geom_edge_link(linewidth = 0.2, alpha = 0.6) +\n    geom_node_point(aes(size = degree, fill = cluster), shape = 21) +\n    scale_fill_brewer(palette = \"Set1\") + \n    coord_fixed() +\n    theme(legend.position = \"none\")\n\n# 'centrality' layout (degree as centrality measure)\np2 &lt;- ggraph(g, layout = \"centrality\", centrality = centrality_degree()) + \n    geom_edge_link(linewidth = 0.2, alpha = 0.6) +\n    geom_node_point(aes(size = degree, fill = cluster), shape = 21) +\n    scale_fill_brewer(palette = \"Set1\") + \n    coord_fixed() +\n    theme(legend.position = \"none\")\n\np1 + p2\n\n\n\n\n\n\n\n\nA big advantage of these layouts, especially the ‘centrality’ layout, is that it’s easier to see node labels, so we can quickly see which nodes are the most important ones in the network. We can add node labels with geom_node_text.\n\n# Add text to label nodes\np2 + geom_node_text(aes(label = name, size = degree), repel = TRUE)\n\n\n\n\n\n\n\n\nFinally, the ‘backbone’ layout can help emphasize hidden group structures in a graph, and its popularity has increased a lot, especially when visualizing large graphs.\n\nggraph(g, layout = \"backbone\", keep = 0.4) +\n    geom_edge_link(linewidth = 0.2, alpha = 0.6) +\n    geom_node_point(aes(size = degree, fill = cluster), shape = 21) +\n    scale_fill_brewer(palette = \"Set1\")\n\n\n\n\n\n\n\n\nAs stated before, it is generally recommended to test multiple layout algorithms, as each of them is optimized for a specific purpose.\n\n\n\n\n\n\nChallenge\n\n\n\nThe yeast network is a very large network containing 2617 nodes. Use the techniques you learned to visualize this network in an efficient way. Test at least two layouts.\nYou can load the data set using the code below.\n\ndata(yeast)\n\nHint: this network contains a node attribute named Class that could be used to group nodes.\n\n\n\n\n\n\nShow me the solutions\n\n\n\n\n\nNote: there is no single right solution for this challenge, but below is a possible approach.\n\n# Decompose graph and get giant component\ng &lt;- decompose(yeast)[[1]]\n\n# Add `degree` and `cluster` node attributes\nV(g)$degree &lt;- degree(g)\n\n# 'backbone' layout\nggraph(g, layout = \"backbone\", keep = 0.4) +\n    geom_edge_link(linewidth = 0.1, alpha = 0.6) +\n    geom_node_point(aes(size = degree, fill = Class), shape = 21) +\n    theme(legend.position = \"none\")\n\n\n\n\n\n\n\n# 'sparse_stress' layout\nggraph(g) +\n    geom_edge_link(linewidth = 0.1, alpha = 0.6) +\n    geom_node_point(aes(size = degree, fill = Class), shape = 21) +\n    theme(legend.position = \"none\")",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Network visualization</span>"
    ]
  },
  {
    "objectID": "chapters/04_network_visualization.html#session-information",
    "href": "chapters/04_network_visualization.html#session-information",
    "title": "4  Network visualization",
    "section": "Session information",
    "text": "Session information\nThis chapter was created under the following conditions:\n\n\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.2 (2023-10-31)\n os       Ubuntu 22.04.3 LTS\n system   x86_64, linux-gnu\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       Europe/Brussels\n date     2024-04-19\n pandoc   3.1.1 @ /usr/lib/rstudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package      * version date (UTC) lib source\n BiocManager    1.30.22 2023-08-08 [1] CRAN (R 4.3.2)\n BiocStyle      2.30.0  2023-10-24 [1] Bioconductor\n cachem         1.0.8   2023-05-01 [1] CRAN (R 4.3.2)\n cli            3.6.2   2023-12-11 [1] CRAN (R 4.3.2)\n colorspace     2.1-0   2023-01-23 [1] CRAN (R 4.3.2)\n deldir         2.0-4   2024-02-28 [1] CRAN (R 4.3.2)\n digest         0.6.34  2024-01-11 [1] CRAN (R 4.3.2)\n dplyr        * 1.1.4   2023-11-17 [1] CRAN (R 4.3.2)\n evaluate       0.23    2023-11-01 [1] CRAN (R 4.3.2)\n fansi          1.0.6   2023-12-08 [1] CRAN (R 4.3.2)\n farver         2.1.1   2022-07-06 [1] CRAN (R 4.3.2)\n fastmap        1.1.1   2023-02-24 [1] CRAN (R 4.3.2)\n forcats      * 1.0.0   2023-01-29 [1] CRAN (R 4.3.2)\n generics       0.1.3   2022-07-05 [1] CRAN (R 4.3.2)\n ggforce        0.4.1   2022-10-04 [1] CRAN (R 4.3.2)\n ggplot2      * 3.5.0   2024-02-23 [1] CRAN (R 4.3.2)\n ggraph       * 2.2.1   2024-03-07 [1] CRAN (R 4.3.2)\n ggrepel        0.9.5   2024-01-10 [1] CRAN (R 4.3.2)\n glue           1.7.0   2024-01-09 [1] CRAN (R 4.3.2)\n graphlayouts   1.1.0   2024-01-19 [1] CRAN (R 4.3.2)\n gridExtra      2.3     2017-09-09 [1] CRAN (R 4.3.2)\n gtable         0.3.4   2023-08-21 [1] CRAN (R 4.3.2)\n here         * 1.0.1   2020-12-13 [1] CRAN (R 4.3.2)\n hms            1.1.3   2023-03-21 [1] CRAN (R 4.3.2)\n htmltools      0.5.7   2023-11-03 [1] CRAN (R 4.3.2)\n htmlwidgets    1.6.4   2023-12-06 [1] CRAN (R 4.3.2)\n igraph       * 2.0.1.1 2024-01-30 [1] CRAN (R 4.3.2)\n igraphdata   * 1.0.1   2015-07-13 [1] CRAN (R 4.3.2)\n jsonlite       1.8.8   2023-12-04 [1] CRAN (R 4.3.2)\n knitr          1.45    2023-10-30 [1] CRAN (R 4.3.2)\n labeling       0.4.3   2023-08-29 [1] CRAN (R 4.3.2)\n lattice        0.22-5  2023-10-24 [4] CRAN (R 4.3.1)\n lifecycle      1.0.4   2023-11-07 [1] CRAN (R 4.3.2)\n lubridate    * 1.9.3   2023-09-27 [1] CRAN (R 4.3.2)\n magrittr       2.0.3   2022-03-30 [1] CRAN (R 4.3.2)\n MASS           7.3-60  2023-05-04 [4] CRAN (R 4.3.1)\n Matrix         1.6-3   2023-11-14 [4] CRAN (R 4.3.2)\n memoise        2.0.1   2021-11-26 [1] CRAN (R 4.3.2)\n munsell        0.5.0   2018-06-12 [1] CRAN (R 4.3.2)\n oaqc           1.0     2017-11-14 [1] CRAN (R 4.3.2)\n patchwork    * 1.2.0   2024-01-08 [1] CRAN (R 4.3.2)\n pillar         1.9.0   2023-03-22 [1] CRAN (R 4.3.2)\n pkgconfig      2.0.3   2019-09-22 [1] CRAN (R 4.3.2)\n polyclip       1.10-6  2023-09-27 [1] CRAN (R 4.3.2)\n purrr        * 1.0.2   2023-08-10 [1] CRAN (R 4.3.2)\n R6             2.5.1   2021-08-19 [1] CRAN (R 4.3.2)\n RColorBrewer   1.1-3   2022-04-03 [1] CRAN (R 4.3.2)\n Rcpp           1.0.12  2024-01-09 [1] CRAN (R 4.3.2)\n readr        * 2.1.5   2024-01-10 [1] CRAN (R 4.3.2)\n rlang          1.1.3   2024-01-10 [1] CRAN (R 4.3.2)\n rmarkdown      2.25    2023-09-18 [1] CRAN (R 4.3.2)\n rprojroot      2.0.4   2023-11-05 [1] CRAN (R 4.3.2)\n rstudioapi     0.15.0  2023-07-07 [1] CRAN (R 4.3.2)\n scales         1.3.0   2023-11-28 [1] CRAN (R 4.3.2)\n sessioninfo    1.2.2   2021-12-06 [1] CRAN (R 4.3.2)\n stringi        1.8.3   2023-12-11 [1] CRAN (R 4.3.2)\n stringr      * 1.5.1   2023-11-14 [1] CRAN (R 4.3.2)\n tibble       * 3.2.1   2023-03-20 [1] CRAN (R 4.3.2)\n tidygraph    * 1.3.1   2024-01-30 [1] CRAN (R 4.3.2)\n tidyr        * 1.3.1   2024-01-24 [1] CRAN (R 4.3.2)\n tidyselect     1.2.0   2022-10-10 [1] CRAN (R 4.3.2)\n tidyverse    * 2.0.0   2023-02-22 [1] CRAN (R 4.3.2)\n timechange     0.3.0   2024-01-18 [1] CRAN (R 4.3.2)\n tweenr         2.0.2   2022-09-06 [1] CRAN (R 4.3.2)\n tzdb           0.4.0   2023-05-12 [1] CRAN (R 4.3.2)\n utf8           1.2.4   2023-10-22 [1] CRAN (R 4.3.2)\n vctrs          0.6.5   2023-12-01 [1] CRAN (R 4.3.2)\n viridis        0.6.5   2024-01-29 [1] CRAN (R 4.3.2)\n viridisLite    0.4.2   2023-05-02 [1] CRAN (R 4.3.2)\n withr          3.0.0   2024-01-16 [1] CRAN (R 4.3.2)\n xfun           0.42    2024-02-08 [1] CRAN (R 4.3.2)\n yaml           2.3.8   2023-12-11 [1] CRAN (R 4.3.2)\n\n [1] /home/faalm/R/x86_64-pc-linux-gnu-library/4.3\n [2] /usr/local/lib/R/site-library\n [3] /usr/lib/R/site-library\n [4] /usr/lib/R/library\n\n──────────────────────────────────────────────────────────────────────────────",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Network visualization</span>"
    ]
  },
  {
    "objectID": "chapters/appendix_01_data_acquisition.html",
    "href": "chapters/appendix_01_data_acquisition.html",
    "title": "Appendix: Data acquisition",
    "section": "",
    "text": "got.rds\nThis file contains an igraph object with a network consisting of character relationships in George R. R. Martin’s A Storm of Swords, the third novel in his series A Song of Ice and Fire. Data were originally compiled by Beveridge and Shan (2016).\n# Get edges\ngot_edges &lt;- read_csv(\n    \"https://raw.githubusercontent.com/melaniewalsh/sample-social-network-datasets/master/sample-datasets/game-of-thrones/got-edges.csv\",\n    show_col_types = FALSE\n) |&gt;\n    dplyr::rename(from = Source, to = Target, weight = Weight) |&gt;\n    as.data.frame()\n\n# Get nodes\ngot_nodes &lt;- read_csv(\n    \"https://raw.githubusercontent.com/melaniewalsh/sample-social-network-datasets/master/sample-datasets/game-of-thrones/got-nodes.csv\",\n    show_col_types = FALSE\n) |&gt;\n    dplyr::rename(node = Id, label = Label) |&gt;\n    as.data.frame()\n\n# Create igraph object\ngot &lt;- graph_from_data_frame(\n    got_edges, directed = FALSE, vertices = got_nodes\n)\n\nsaveRDS(\n    got, compress = \"xz\", file = here(\"data\", \"got.rds\")\n)",
    "crumbs": [
      "Appendix: Data acquisition"
    ]
  },
  {
    "objectID": "chapters/appendix_01_data_acquisition.html#references",
    "href": "chapters/appendix_01_data_acquisition.html#references",
    "title": "Appendix: Data acquisition",
    "section": "References",
    "text": "References\n\n\n\n\nBeveridge, Andrew, and Jie Shan. 2016. “Network of Thrones.” Math Horizons 23 (4): 18–22.",
    "crumbs": [
      "Appendix: Data acquisition"
    ]
  }
]